{"ast":null,"code":"/**\r\n * Most browsers don't yet have async iterable support for ReadableStream,\r\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\r\n *\r\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\r\n */\nexport function ReadableStreamToAsyncIterable(stream) {\n  if (stream[Symbol.asyncIterator]) return stream;\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result !== null && result !== void 0 && result.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return {\n        done: true,\n        value: undefined\n      };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}","map":{"version":3,"names":["ReadableStreamToAsyncIterable","stream","Symbol","asyncIterator","reader","getReader","next","result","read","done","releaseLock","e","return","cancelPromise","cancel","value","undefined"],"sources":["C:\\co-1016\\node_modules\\openai\\src\\internal\\stream-utils.ts"],"sourcesContent":["/**\r\n * Most browsers don't yet have async iterable support for ReadableStream,\r\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\r\n *\r\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\r\n */\r\nexport function ReadableStreamToAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\r\n  if (stream[Symbol.asyncIterator]) return stream;\r\n\r\n  const reader = stream.getReader();\r\n  return {\r\n    async next() {\r\n      try {\r\n        const result = await reader.read();\r\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\r\n        return result;\r\n      } catch (e) {\r\n        reader.releaseLock(); // release lock when stream becomes errored\r\n        throw e;\r\n      }\r\n    },\r\n    async return() {\r\n      const cancelPromise = reader.cancel();\r\n      reader.releaseLock();\r\n      await cancelPromise;\r\n      return { done: true, value: undefined };\r\n    },\r\n    [Symbol.asyncIterator]() {\r\n      return this;\r\n    },\r\n  };\r\n}\r\n"],"mappings":"AAAA;;;;;;AAMA,OAAM,SAAUA,6BAA6BA,CAAIC,MAAW;EAC1D,IAAIA,MAAM,CAACC,MAAM,CAACC,aAAa,CAAC,EAAE,OAAOF,MAAM;EAE/C,MAAMG,MAAM,GAAGH,MAAM,CAACI,SAAS,EAAE;EACjC,OAAO;IACL,MAAMC,IAAIA,CAAA;MACR,IAAI;QACF,MAAMC,MAAM,GAAG,MAAMH,MAAM,CAACI,IAAI,EAAE;QAClC,IAAID,MAAM,aAANA,MAAM,eAANA,MAAM,CAAEE,IAAI,EAAEL,MAAM,CAACM,WAAW,EAAE,CAAC,CAAC;QACxC,OAAOH,MAAM;OACd,CAAC,OAAOI,CAAC,EAAE;QACVP,MAAM,CAACM,WAAW,EAAE,CAAC,CAAC;QACtB,MAAMC,CAAC;;IAEX,CAAC;IACD,MAAMC,MAAMA,CAAA;MACV,MAAMC,aAAa,GAAGT,MAAM,CAACU,MAAM,EAAE;MACrCV,MAAM,CAACM,WAAW,EAAE;MACpB,MAAMG,aAAa;MACnB,OAAO;QAAEJ,IAAI,EAAE,IAAI;QAAEM,KAAK,EAAEC;MAAS,CAAE;IACzC,CAAC;IACD,CAACd,MAAM,CAACC,aAAa,IAAC;MACpB,OAAO,IAAI;IACb;GACD;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}