{"ast":null,"code":"import _objectSpread from \"C:/co-1016/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncIterator from \"C:/co-1016/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ResponseStream_instances, _ResponseStream_params, _ResponseStream_currentResponseSnapshot, _ResponseStream_finalResponse, _ResponseStream_beginRequest, _ResponseStream_addEvent, _ResponseStream_endRequest, _ResponseStream_accumulateResponse;\nimport { APIUserAbortError, OpenAIError } from \"../../error.mjs\";\nimport { EventStream } from \"../EventStream.mjs\";\nimport { maybeParseResponse } from \"../ResponsesParser.mjs\";\nexport class ResponseStream extends EventStream {\n  constructor(params) {\n    super();\n    _ResponseStream_instances.add(this);\n    _ResponseStream_params.set(this, void 0);\n    _ResponseStream_currentResponseSnapshot.set(this, void 0);\n    _ResponseStream_finalResponse.set(this, void 0);\n    __classPrivateFieldSet(this, _ResponseStream_params, params, \"f\");\n  }\n  static createResponse(client, params, options) {\n    const runner = new ResponseStream(params);\n    runner._run(() => runner._createOrRetrieveResponse(client, params, _objectSpread(_objectSpread({}, options), {}, {\n      headers: _objectSpread(_objectSpread({}, options === null || options === void 0 ? void 0 : options.headers), {}, {\n        'X-Stainless-Helper-Method': 'stream'\n      })\n    })));\n    return runner;\n  }\n  async _createOrRetrieveResponse(client, params, options) {\n    var _stream$controller$si;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_beginRequest).call(this);\n    let stream;\n    let starting_after = null;\n    if ('response_id' in params) {\n      var _params$starting_afte;\n      stream = await client.responses.retrieve(params.response_id, {\n        stream: true\n      }, _objectSpread(_objectSpread({}, options), {}, {\n        signal: this.controller.signal,\n        stream: true\n      }));\n      starting_after = (_params$starting_afte = params.starting_after) !== null && _params$starting_afte !== void 0 ? _params$starting_afte : null;\n    } else {\n      stream = await client.responses.create(_objectSpread(_objectSpread({}, params), {}, {\n        stream: true\n      }), _objectSpread(_objectSpread({}, options), {}, {\n        signal: this.controller.signal\n      }));\n    }\n    this._connected();\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(stream), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n        const event = _step.value;\n        {\n          __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_addEvent).call(this, event, starting_after);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    if ((_stream$controller$si = stream.controller.signal) !== null && _stream$controller$si !== void 0 && _stream$controller$si.aborted) {\n      throw new APIUserAbortError();\n    }\n    return __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_endRequest).call(this);\n  }\n  [(_ResponseStream_params = new WeakMap(), _ResponseStream_currentResponseSnapshot = new WeakMap(), _ResponseStream_finalResponse = new WeakMap(), _ResponseStream_instances = new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest() {\n    if (this.ended) return;\n    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, undefined, \"f\");\n  }, _ResponseStream_addEvent = function _ResponseStream_addEvent(event, starting_after) {\n    if (this.ended) return;\n    const maybeEmit = (name, event) => {\n      if (starting_after == null || event.sequence_number > starting_after) {\n        this._emit(name, event);\n      }\n    };\n    const response = __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_accumulateResponse).call(this, event);\n    maybeEmit('event', event);\n    switch (event.type) {\n      case 'response.output_text.delta':\n        {\n          const output = response.output[event.output_index];\n          if (!output) {\n            throw new OpenAIError(\"missing output at index \".concat(event.output_index));\n          }\n          if (output.type === 'message') {\n            const content = output.content[event.content_index];\n            if (!content) {\n              throw new OpenAIError(\"missing content at index \".concat(event.content_index));\n            }\n            if (content.type !== 'output_text') {\n              throw new OpenAIError(\"expected content to be 'output_text', got \".concat(content.type));\n            }\n            maybeEmit('response.output_text.delta', _objectSpread(_objectSpread({}, event), {}, {\n              snapshot: content.text\n            }));\n          }\n          break;\n        }\n      case 'response.function_call_arguments.delta':\n        {\n          const output = response.output[event.output_index];\n          if (!output) {\n            throw new OpenAIError(\"missing output at index \".concat(event.output_index));\n          }\n          if (output.type === 'function_call') {\n            maybeEmit('response.function_call_arguments.delta', _objectSpread(_objectSpread({}, event), {}, {\n              snapshot: output.arguments\n            }));\n          }\n          break;\n        }\n      default:\n        maybeEmit(event.type, event);\n        break;\n    }\n  }, _ResponseStream_endRequest = function _ResponseStream_endRequest() {\n    if (this.ended) {\n      throw new OpenAIError(\"stream has ended, this shouldn't happen\");\n    }\n    const snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, \"f\");\n    if (!snapshot) {\n      throw new OpenAIError(\"request ended without sending any events\");\n    }\n    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, undefined, \"f\");\n    const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet(this, _ResponseStream_params, \"f\"));\n    __classPrivateFieldSet(this, _ResponseStream_finalResponse, parsedResponse, \"f\");\n    return parsedResponse;\n  }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse(event) {\n    let snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, \"f\");\n    if (!snapshot) {\n      if (event.type !== 'response.created') {\n        throw new OpenAIError(\"When snapshot hasn't been set yet, expected 'response.created' event, got \".concat(event.type));\n      }\n      snapshot = __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, \"f\");\n      return snapshot;\n    }\n    switch (event.type) {\n      case 'response.output_item.added':\n        {\n          snapshot.output.push(event.item);\n          break;\n        }\n      case 'response.content_part.added':\n        {\n          const output = snapshot.output[event.output_index];\n          if (!output) {\n            throw new OpenAIError(\"missing output at index \".concat(event.output_index));\n          }\n          if (output.type === 'message') {\n            output.content.push(event.part);\n          }\n          break;\n        }\n      case 'response.output_text.delta':\n        {\n          const output = snapshot.output[event.output_index];\n          if (!output) {\n            throw new OpenAIError(\"missing output at index \".concat(event.output_index));\n          }\n          if (output.type === 'message') {\n            const content = output.content[event.content_index];\n            if (!content) {\n              throw new OpenAIError(\"missing content at index \".concat(event.content_index));\n            }\n            if (content.type !== 'output_text') {\n              throw new OpenAIError(\"expected content to be 'output_text', got \".concat(content.type));\n            }\n            content.text += event.delta;\n          }\n          break;\n        }\n      case 'response.function_call_arguments.delta':\n        {\n          const output = snapshot.output[event.output_index];\n          if (!output) {\n            throw new OpenAIError(\"missing output at index \".concat(event.output_index));\n          }\n          if (output.type === 'function_call') {\n            output.arguments += event.delta;\n          }\n          break;\n        }\n      case 'response.completed':\n        {\n          __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, \"f\");\n          break;\n        }\n    }\n    return snapshot;\n  }, Symbol.asyncIterator)]() {\n    const pushQueue = [];\n    const readQueue = [];\n    let done = false;\n    this.on('event', event => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(event);\n      } else {\n        pushQueue.push(event);\n      }\n    });\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n    this.on('abort', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    this.on('error', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    return {\n      next: async () => {\n        if (!pushQueue.length) {\n          if (done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          return new Promise((resolve, reject) => readQueue.push({\n            resolve,\n            reject\n          })).then(event => event ? {\n            value: event,\n            done: false\n          } : {\n            value: undefined,\n            done: true\n          });\n        }\n        const event = pushQueue.shift();\n        return {\n          value: event,\n          done: false\n        };\n      },\n      return: async () => {\n        this.abort();\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  /**\r\n   * @returns a promise that resolves with the final Response, or rejects\r\n   * if an error occurred or the stream ended prematurely without producing a REsponse.\r\n   */\n  async finalResponse() {\n    await this.done();\n    const response = __classPrivateFieldGet(this, _ResponseStream_finalResponse, \"f\");\n    if (!response) throw new OpenAIError('stream ended without producing a ChatCompletion');\n    return response;\n  }\n}\nfunction finalizeResponse(snapshot, params) {\n  return maybeParseResponse(snapshot, params);\n}","map":{"version":3,"names":["APIUserAbortError","OpenAIError","EventStream","maybeParseResponse","ResponseStream","constructor","params","_ResponseStream_params","set","_ResponseStream_currentResponseSnapshot","_ResponseStream_finalResponse","__classPrivateFieldSet","createResponse","client","options","runner","_run","_createOrRetrieveResponse","_objectSpread","headers","_stream$controller$si","signal","aborted","controller","abort","addEventListener","__classPrivateFieldGet","_ResponseStream_instances","_ResponseStream_beginRequest","call","stream","starting_after","_params$starting_afte","responses","retrieve","response_id","create","_connected","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","_step","next","done","event","value","_ResponseStream_addEvent","err","return","_ResponseStream_endRequest","WeakMap","WeakSet","ended","undefined","maybeEmit","name","sequence_number","_emit","response","_ResponseStream_accumulateResponse","type","output","output_index","concat","content","content_index","snapshot","text","arguments","parsedResponse","finalizeResponse","push","item","part","delta","Symbol","asyncIterator","pushQueue","readQueue","on","reader","shift","resolve","length","reject","Promise","then","finalResponse"],"sources":["C:\\co-1016\\node_modules\\openai\\src\\lib\\responses\\ResponseStream.ts"],"sourcesContent":["import {\r\n  ResponseTextConfig,\r\n  type ParsedResponse,\r\n  type Response,\r\n  type ResponseCreateParamsBase,\r\n  type ResponseCreateParamsStreaming,\r\n  type ResponseStreamEvent,\r\n} from '../../resources/responses/responses';\r\nimport * as Core from '../../core';\r\nimport { APIUserAbortError, OpenAIError } from '../../error';\r\nimport OpenAI from '../../index';\r\nimport { type BaseEvents, EventStream } from '../EventStream';\r\nimport { type ResponseFunctionCallArgumentsDeltaEvent, type ResponseTextDeltaEvent } from './EventTypes';\r\nimport { maybeParseResponse, ParseableToolsParams } from '../ResponsesParser';\r\nimport { Stream } from \"../../streaming\";\r\n\r\nexport type ResponseStreamParams = ResponseCreateAndStreamParams | ResponseStreamByIdParams;\r\n\r\nexport type ResponseCreateAndStreamParams = Omit<ResponseCreateParamsBase, 'stream'> & {\r\n  stream?: true;\r\n};\r\n\r\nexport type ResponseStreamByIdParams = {\r\n  /**\r\n   * The ID of the response to stream.\r\n   */\r\n  response_id: string;\r\n  /**\r\n   * If provided, the stream will start after the event with the given sequence number.\r\n   */\r\n  starting_after?: number;\r\n  /**\r\n   * Configuration options for a text response from the model. Can be plain text or\r\n   * structured JSON data. Learn more:\r\n   *\r\n   * - [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\r\n   * - [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\r\n   */\r\n  text?: ResponseTextConfig;\r\n\r\n  /**\r\n   * An array of tools the model may call while generating a response. When continuing a stream, provide\r\n   * the same tools as the original request.\r\n   */\r\n  tools?: ParseableToolsParams;\r\n};\r\n\r\ntype ResponseEvents = BaseEvents &\r\n  Omit<\r\n    {\r\n      [K in ResponseStreamEvent['type']]: (event: Extract<ResponseStreamEvent, { type: K }>) => void;\r\n    },\r\n    'response.output_text.delta' | 'response.function_call_arguments.delta'\r\n  > & {\r\n    event: (event: ResponseStreamEvent) => void;\r\n    'response.output_text.delta': (event: ResponseTextDeltaEvent) => void;\r\n    'response.function_call_arguments.delta': (event: ResponseFunctionCallArgumentsDeltaEvent) => void;\r\n  };\r\n\r\nexport type ResponseStreamingParams = Omit<ResponseCreateParamsBase, 'stream'> & {\r\n  stream?: true;\r\n};\r\n\r\nexport class ResponseStream<ParsedT = null>\r\n  extends EventStream<ResponseEvents>\r\n  implements AsyncIterable<ResponseStreamEvent>\r\n{\r\n  #params: ResponseStreamingParams | null;\r\n  #currentResponseSnapshot: Response | undefined;\r\n  #finalResponse: ParsedResponse<ParsedT> | undefined;\r\n\r\n  constructor(params: ResponseStreamingParams | null) {\r\n    super();\r\n    this.#params = params;\r\n  }\r\n\r\n  static createResponse<ParsedT>(\r\n    client: OpenAI,\r\n    params: ResponseStreamParams,\r\n    options?: Core.RequestOptions,\r\n  ): ResponseStream<ParsedT> {\r\n    const runner = new ResponseStream<ParsedT>(params as ResponseCreateParamsStreaming);\r\n    runner._run(() =>\r\n      runner._createOrRetrieveResponse(client, params, {\r\n        ...options,\r\n        headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\r\n      }),\r\n    );\r\n    return runner;\r\n  }\r\n\r\n  #beginRequest() {\r\n    if (this.ended) return;\r\n    this.#currentResponseSnapshot = undefined;\r\n  }\r\n\r\n  #addEvent(this: ResponseStream<ParsedT>, event: ResponseStreamEvent, starting_after: number | null) {\r\n    if (this.ended) return;\r\n\r\n    const maybeEmit = (name: string, event: ResponseStreamEvent & { snapshot?: string }) => {\r\n      if (starting_after == null || event.sequence_number > starting_after) {\r\n        this._emit(name as any, event);\r\n      }\r\n    };\r\n\r\n    const response = this.#accumulateResponse(event);\r\n    maybeEmit('event', event);\r\n\r\n    switch (event.type) {\r\n      case 'response.output_text.delta': {\r\n        const output = response.output[event.output_index];\r\n        if (!output) {\r\n          throw new OpenAIError(`missing output at index ${event.output_index}`);\r\n        }\r\n        if (output.type === 'message') {\r\n          const content = output.content[event.content_index];\r\n          if (!content) {\r\n            throw new OpenAIError(`missing content at index ${event.content_index}`);\r\n          }\r\n          if (content.type !== 'output_text') {\r\n            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);\r\n          }\r\n\r\n          maybeEmit('response.output_text.delta', {\r\n            ...event,\r\n            snapshot: content.text,\r\n          });\r\n        }\r\n        break;\r\n      }\r\n      case 'response.function_call_arguments.delta': {\r\n        const output = response.output[event.output_index];\r\n        if (!output) {\r\n          throw new OpenAIError(`missing output at index ${event.output_index}`);\r\n        }\r\n        if (output.type === 'function_call') {\r\n          maybeEmit('response.function_call_arguments.delta', {\r\n            ...event,\r\n            snapshot: output.arguments,\r\n          });\r\n        }\r\n        break;\r\n      }\r\n      default:\r\n        maybeEmit(event.type, event);\r\n        break;\r\n    }\r\n  }\r\n\r\n  #endRequest(): ParsedResponse<ParsedT> {\r\n    if (this.ended) {\r\n      throw new OpenAIError(`stream has ended, this shouldn't happen`);\r\n    }\r\n    const snapshot = this.#currentResponseSnapshot;\r\n    if (!snapshot) {\r\n      throw new OpenAIError(`request ended without sending any events`);\r\n    }\r\n    this.#currentResponseSnapshot = undefined;\r\n    const parsedResponse = finalizeResponse<ParsedT>(snapshot, this.#params);\r\n    this.#finalResponse = parsedResponse;\r\n\r\n    return parsedResponse;\r\n  }\r\n\r\n  protected async _createOrRetrieveResponse(\r\n    client: OpenAI,\r\n    params: ResponseStreamParams,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<ParsedResponse<ParsedT>> {\r\n    const signal = options?.signal;\r\n    if (signal) {\r\n      if (signal.aborted) this.controller.abort();\r\n      signal.addEventListener('abort', () => this.controller.abort());\r\n    }\r\n    this.#beginRequest();\r\n\r\n    let stream: Stream<ResponseStreamEvent> | undefined;\r\n    let starting_after: number | null = null;\r\n    if ('response_id' in params) {\r\n      stream = await client.responses.retrieve(\r\n        params.response_id,\r\n        { stream: true },\r\n        { ...options, signal: this.controller.signal, stream: true },\r\n      );\r\n      starting_after = params.starting_after ?? null;\r\n    } else {\r\n      stream = await client.responses.create(\r\n        { ...params, stream: true },\r\n        { ...options, signal: this.controller.signal },\r\n      );\r\n    }\r\n\r\n    this._connected();\r\n    for await (const event of stream) {\r\n      this.#addEvent(event, starting_after);\r\n    }\r\n    if (stream.controller.signal?.aborted) {\r\n      throw new APIUserAbortError();\r\n    }\r\n    return this.#endRequest();\r\n  }\r\n\r\n  #accumulateResponse(event: ResponseStreamEvent): Response {\r\n    let snapshot = this.#currentResponseSnapshot;\r\n    if (!snapshot) {\r\n      if (event.type !== 'response.created') {\r\n        throw new OpenAIError(\r\n          `When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`,\r\n        );\r\n      }\r\n      snapshot = this.#currentResponseSnapshot = event.response;\r\n      return snapshot;\r\n    }\r\n\r\n    switch (event.type) {\r\n      case 'response.output_item.added': {\r\n        snapshot.output.push(event.item);\r\n        break;\r\n      }\r\n      case 'response.content_part.added': {\r\n        const output = snapshot.output[event.output_index];\r\n        if (!output) {\r\n          throw new OpenAIError(`missing output at index ${event.output_index}`);\r\n        }\r\n        if (output.type === 'message') {\r\n          output.content.push(event.part);\r\n        }\r\n        break;\r\n      }\r\n      case 'response.output_text.delta': {\r\n        const output = snapshot.output[event.output_index];\r\n        if (!output) {\r\n          throw new OpenAIError(`missing output at index ${event.output_index}`);\r\n        }\r\n        if (output.type === 'message') {\r\n          const content = output.content[event.content_index];\r\n          if (!content) {\r\n            throw new OpenAIError(`missing content at index ${event.content_index}`);\r\n          }\r\n          if (content.type !== 'output_text') {\r\n            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);\r\n          }\r\n          content.text += event.delta;\r\n        }\r\n        break;\r\n      }\r\n      case 'response.function_call_arguments.delta': {\r\n        const output = snapshot.output[event.output_index];\r\n        if (!output) {\r\n          throw new OpenAIError(`missing output at index ${event.output_index}`);\r\n        }\r\n        if (output.type === 'function_call') {\r\n          output.arguments += event.delta;\r\n        }\r\n        break;\r\n      }\r\n      case 'response.completed': {\r\n        this.#currentResponseSnapshot = event.response;\r\n        break;\r\n      }\r\n    }\r\n\r\n    return snapshot;\r\n  }\r\n\r\n  [Symbol.asyncIterator](this: ResponseStream<ParsedT>): AsyncIterator<ResponseStreamEvent> {\r\n    const pushQueue: ResponseStreamEvent[] = [];\r\n    const readQueue: {\r\n      resolve: (event: ResponseStreamEvent | undefined) => void;\r\n      reject: (err: unknown) => void;\r\n    }[] = [];\r\n    let done = false;\r\n\r\n    this.on('event', (event) => {\r\n      const reader = readQueue.shift();\r\n      if (reader) {\r\n        reader.resolve(event);\r\n      } else {\r\n        pushQueue.push(event);\r\n      }\r\n    });\r\n\r\n    this.on('end', () => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.resolve(undefined);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    this.on('abort', (err) => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.reject(err);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    this.on('error', (err) => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.reject(err);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    return {\r\n      next: async (): Promise<IteratorResult<ResponseStreamEvent>> => {\r\n        if (!pushQueue.length) {\r\n          if (done) {\r\n            return { value: undefined, done: true };\r\n          }\r\n          return new Promise<ResponseStreamEvent | undefined>((resolve, reject) =>\r\n            readQueue.push({ resolve, reject }),\r\n          ).then((event) => (event ? { value: event, done: false } : { value: undefined, done: true }));\r\n        }\r\n        const event = pushQueue.shift()!;\r\n        return { value: event, done: false };\r\n      },\r\n      return: async () => {\r\n        this.abort();\r\n        return { value: undefined, done: true };\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @returns a promise that resolves with the final Response, or rejects\r\n   * if an error occurred or the stream ended prematurely without producing a REsponse.\r\n   */\r\n  async finalResponse(): Promise<ParsedResponse<ParsedT>> {\r\n    await this.done();\r\n    const response = this.#finalResponse;\r\n    if (!response) throw new OpenAIError('stream ended without producing a ChatCompletion');\r\n    return response;\r\n  }\r\n}\r\n\r\nfunction finalizeResponse<ParsedT>(\r\n  snapshot: Response,\r\n  params: ResponseStreamingParams | null,\r\n): ParsedResponse<ParsedT> {\r\n  return maybeParseResponse(snapshot, params);\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}