{"ast":null,"code":"const STR = 0b000000001;\nconst NUM = 0b000000010;\nconst ARR = 0b000000100;\nconst OBJ = 0b000001000;\nconst NULL = 0b000010000;\nconst BOOL = 0b000100000;\nconst NAN = 0b001000000;\nconst INFINITY = 0b010000000;\nconst MINUS_INFINITY = 0b100000000;\nconst INF = INFINITY | MINUS_INFINITY;\nconst SPECIAL = NULL | BOOL | INF | NAN;\nconst ATOM = STR | NUM | SPECIAL;\nconst COLLECTION = ARR | OBJ;\nconst ALL = ATOM | COLLECTION;\nconst Allow = {\n  STR,\n  NUM,\n  ARR,\n  OBJ,\n  NULL,\n  BOOL,\n  NAN,\n  INFINITY,\n  MINUS_INFINITY,\n  INF,\n  SPECIAL,\n  ATOM,\n  COLLECTION,\n  ALL\n};\n// The JSON string segment was unable to be parsed completely\nclass PartialJSON extends Error {}\nclass MalformedJSON extends Error {}\n/**\r\n * Parse incomplete JSON\r\n * @param {string} jsonString Partial JSON to be parsed\r\n * @param {number} allowPartial Specify what types are allowed to be partial, see {@link Allow} for details\r\n * @returns The parsed JSON\r\n * @throws {PartialJSON} If the JSON is incomplete (related to the `allow` parameter)\r\n * @throws {MalformedJSON} If the JSON is malformed\r\n */\nfunction parseJSON(jsonString) {\n  let allowPartial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Allow.ALL;\n  if (typeof jsonString !== 'string') {\n    throw new TypeError(\"expecting str, got \".concat(typeof jsonString));\n  }\n  if (!jsonString.trim()) {\n    throw new Error(\"\".concat(jsonString, \" is empty\"));\n  }\n  return _parseJSON(jsonString.trim(), allowPartial);\n}\nconst _parseJSON = (jsonString, allow) => {\n  const length = jsonString.length;\n  let index = 0;\n  const markPartialJSON = msg => {\n    throw new PartialJSON(\"\".concat(msg, \" at position \").concat(index));\n  };\n  const throwMalformedError = msg => {\n    throw new MalformedJSON(\"\".concat(msg, \" at position \").concat(index));\n  };\n  const parseAny = () => {\n    skipBlank();\n    if (index >= length) markPartialJSON('Unexpected end of input');\n    if (jsonString[index] === '\"') return parseStr();\n    if (jsonString[index] === '{') return parseObj();\n    if (jsonString[index] === '[') return parseArr();\n    if (jsonString.substring(index, index + 4) === 'null' || Allow.NULL & allow && length - index < 4 && 'null'.startsWith(jsonString.substring(index))) {\n      index += 4;\n      return null;\n    }\n    if (jsonString.substring(index, index + 4) === 'true' || Allow.BOOL & allow && length - index < 4 && 'true'.startsWith(jsonString.substring(index))) {\n      index += 4;\n      return true;\n    }\n    if (jsonString.substring(index, index + 5) === 'false' || Allow.BOOL & allow && length - index < 5 && 'false'.startsWith(jsonString.substring(index))) {\n      index += 5;\n      return false;\n    }\n    if (jsonString.substring(index, index + 8) === 'Infinity' || Allow.INFINITY & allow && length - index < 8 && 'Infinity'.startsWith(jsonString.substring(index))) {\n      index += 8;\n      return Infinity;\n    }\n    if (jsonString.substring(index, index + 9) === '-Infinity' || Allow.MINUS_INFINITY & allow && 1 < length - index && length - index < 9 && '-Infinity'.startsWith(jsonString.substring(index))) {\n      index += 9;\n      return -Infinity;\n    }\n    if (jsonString.substring(index, index + 3) === 'NaN' || Allow.NAN & allow && length - index < 3 && 'NaN'.startsWith(jsonString.substring(index))) {\n      index += 3;\n      return NaN;\n    }\n    return parseNum();\n  };\n  const parseStr = () => {\n    const start = index;\n    let escape = false;\n    index++; // skip initial quote\n    while (index < length && (jsonString[index] !== '\"' || escape && jsonString[index - 1] === '\\\\')) {\n      escape = jsonString[index] === '\\\\' ? !escape : false;\n      index++;\n    }\n    if (jsonString.charAt(index) == '\"') {\n      try {\n        return JSON.parse(jsonString.substring(start, ++index - Number(escape)));\n      } catch (e) {\n        throwMalformedError(String(e));\n      }\n    } else if (Allow.STR & allow) {\n      try {\n        return JSON.parse(jsonString.substring(start, index - Number(escape)) + '\"');\n      } catch (e) {\n        // SyntaxError: Invalid escape sequence\n        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('\\\\')) + '\"');\n      }\n    }\n    markPartialJSON('Unterminated string literal');\n  };\n  const parseObj = () => {\n    index++; // skip initial brace\n    skipBlank();\n    const obj = {};\n    try {\n      while (jsonString[index] !== '}') {\n        skipBlank();\n        if (index >= length && Allow.OBJ & allow) return obj;\n        const key = parseStr();\n        skipBlank();\n        index++; // skip colon\n        try {\n          const value = parseAny();\n          Object.defineProperty(obj, key, {\n            value,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        } catch (e) {\n          if (Allow.OBJ & allow) return obj;else throw e;\n        }\n        skipBlank();\n        if (jsonString[index] === ',') index++; // skip comma\n      }\n    } catch (e) {\n      if (Allow.OBJ & allow) return obj;else markPartialJSON(\"Expected '}' at end of object\");\n    }\n    index++; // skip final brace\n    return obj;\n  };\n  const parseArr = () => {\n    index++; // skip initial bracket\n    const arr = [];\n    try {\n      while (jsonString[index] !== ']') {\n        arr.push(parseAny());\n        skipBlank();\n        if (jsonString[index] === ',') {\n          index++; // skip comma\n        }\n      }\n    } catch (e) {\n      if (Allow.ARR & allow) {\n        return arr;\n      }\n      markPartialJSON(\"Expected ']' at end of array\");\n    }\n    index++; // skip final bracket\n    return arr;\n  };\n  const parseNum = () => {\n    if (index === 0) {\n      if (jsonString === '-' && Allow.NUM & allow) markPartialJSON(\"Not sure what '-' is\");\n      try {\n        return JSON.parse(jsonString);\n      } catch (e) {\n        if (Allow.NUM & allow) {\n          try {\n            if ('.' === jsonString[jsonString.length - 1]) return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('.')));\n            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('e')));\n          } catch (e) {}\n        }\n        throwMalformedError(String(e));\n      }\n    }\n    const start = index;\n    if (jsonString[index] === '-') index++;\n    while (jsonString[index] && !',]}'.includes(jsonString[index])) index++;\n    if (index == length && !(Allow.NUM & allow)) markPartialJSON('Unterminated number literal');\n    try {\n      return JSON.parse(jsonString.substring(start, index));\n    } catch (e) {\n      if (jsonString.substring(start, index) === '-' && Allow.NUM & allow) markPartialJSON(\"Not sure what '-' is\");\n      try {\n        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('e')));\n      } catch (e) {\n        throwMalformedError(String(e));\n      }\n    }\n  };\n  const skipBlank = () => {\n    while (index < length && ' \\n\\r\\t'.includes(jsonString[index])) {\n      index++;\n    }\n  };\n  return parseAny();\n};\n// using this function with malformed JSON is undefined behavior\nconst partialParse = input => parseJSON(input, Allow.ALL ^ Allow.NUM);\nexport { partialParse, PartialJSON, MalformedJSON };","map":{"version":3,"names":["STR","NUM","ARR","OBJ","NULL","BOOL","NAN","INFINITY","MINUS_INFINITY","INF","SPECIAL","ATOM","COLLECTION","ALL","Allow","PartialJSON","Error","MalformedJSON","parseJSON","jsonString","allowPartial","arguments","length","undefined","TypeError","concat","trim","_parseJSON","allow","index","markPartialJSON","msg","throwMalformedError","parseAny","skipBlank","parseStr","parseObj","parseArr","substring","startsWith","Infinity","NaN","parseNum","start","escape","charAt","JSON","parse","Number","e","String","lastIndexOf","obj","key","value","Object","defineProperty","writable","enumerable","configurable","arr","push","includes","partialParse","input"],"sources":["C:\\co-1016\\node_modules\\openai\\src\\_vendor\\partial-json-parser\\parser.ts"],"sourcesContent":["const STR = 0b000000001;\r\nconst NUM = 0b000000010;\r\nconst ARR = 0b000000100;\r\nconst OBJ = 0b000001000;\r\nconst NULL = 0b000010000;\r\nconst BOOL = 0b000100000;\r\nconst NAN = 0b001000000;\r\nconst INFINITY = 0b010000000;\r\nconst MINUS_INFINITY = 0b100000000;\r\n\r\nconst INF = INFINITY | MINUS_INFINITY;\r\nconst SPECIAL = NULL | BOOL | INF | NAN;\r\nconst ATOM = STR | NUM | SPECIAL;\r\nconst COLLECTION = ARR | OBJ;\r\nconst ALL = ATOM | COLLECTION;\r\n\r\nconst Allow = {\r\n  STR,\r\n  NUM,\r\n  ARR,\r\n  OBJ,\r\n  NULL,\r\n  BOOL,\r\n  NAN,\r\n  INFINITY,\r\n  MINUS_INFINITY,\r\n  INF,\r\n  SPECIAL,\r\n  ATOM,\r\n  COLLECTION,\r\n  ALL,\r\n};\r\n\r\n// The JSON string segment was unable to be parsed completely\r\nclass PartialJSON extends Error {}\r\n\r\nclass MalformedJSON extends Error {}\r\n\r\n/**\r\n * Parse incomplete JSON\r\n * @param {string} jsonString Partial JSON to be parsed\r\n * @param {number} allowPartial Specify what types are allowed to be partial, see {@link Allow} for details\r\n * @returns The parsed JSON\r\n * @throws {PartialJSON} If the JSON is incomplete (related to the `allow` parameter)\r\n * @throws {MalformedJSON} If the JSON is malformed\r\n */\r\nfunction parseJSON(jsonString: string, allowPartial: number = Allow.ALL): any {\r\n  if (typeof jsonString !== 'string') {\r\n    throw new TypeError(`expecting str, got ${typeof jsonString}`);\r\n  }\r\n  if (!jsonString.trim()) {\r\n    throw new Error(`${jsonString} is empty`);\r\n  }\r\n  return _parseJSON(jsonString.trim(), allowPartial);\r\n}\r\n\r\nconst _parseJSON = (jsonString: string, allow: number) => {\r\n  const length = jsonString.length;\r\n  let index = 0;\r\n\r\n  const markPartialJSON = (msg: string) => {\r\n    throw new PartialJSON(`${msg} at position ${index}`);\r\n  };\r\n\r\n  const throwMalformedError = (msg: string) => {\r\n    throw new MalformedJSON(`${msg} at position ${index}`);\r\n  };\r\n\r\n  const parseAny: () => any = () => {\r\n    skipBlank();\r\n    if (index >= length) markPartialJSON('Unexpected end of input');\r\n    if (jsonString[index] === '\"') return parseStr();\r\n    if (jsonString[index] === '{') return parseObj();\r\n    if (jsonString[index] === '[') return parseArr();\r\n    if (\r\n      jsonString.substring(index, index + 4) === 'null' ||\r\n      (Allow.NULL & allow && length - index < 4 && 'null'.startsWith(jsonString.substring(index)))\r\n    ) {\r\n      index += 4;\r\n      return null;\r\n    }\r\n    if (\r\n      jsonString.substring(index, index + 4) === 'true' ||\r\n      (Allow.BOOL & allow && length - index < 4 && 'true'.startsWith(jsonString.substring(index)))\r\n    ) {\r\n      index += 4;\r\n      return true;\r\n    }\r\n    if (\r\n      jsonString.substring(index, index + 5) === 'false' ||\r\n      (Allow.BOOL & allow && length - index < 5 && 'false'.startsWith(jsonString.substring(index)))\r\n    ) {\r\n      index += 5;\r\n      return false;\r\n    }\r\n    if (\r\n      jsonString.substring(index, index + 8) === 'Infinity' ||\r\n      (Allow.INFINITY & allow && length - index < 8 && 'Infinity'.startsWith(jsonString.substring(index)))\r\n    ) {\r\n      index += 8;\r\n      return Infinity;\r\n    }\r\n    if (\r\n      jsonString.substring(index, index + 9) === '-Infinity' ||\r\n      (Allow.MINUS_INFINITY & allow &&\r\n        1 < length - index &&\r\n        length - index < 9 &&\r\n        '-Infinity'.startsWith(jsonString.substring(index)))\r\n    ) {\r\n      index += 9;\r\n      return -Infinity;\r\n    }\r\n    if (\r\n      jsonString.substring(index, index + 3) === 'NaN' ||\r\n      (Allow.NAN & allow && length - index < 3 && 'NaN'.startsWith(jsonString.substring(index)))\r\n    ) {\r\n      index += 3;\r\n      return NaN;\r\n    }\r\n    return parseNum();\r\n  };\r\n\r\n  const parseStr: () => string = () => {\r\n    const start = index;\r\n    let escape = false;\r\n    index++; // skip initial quote\r\n    while (index < length && (jsonString[index] !== '\"' || (escape && jsonString[index - 1] === '\\\\'))) {\r\n      escape = jsonString[index] === '\\\\' ? !escape : false;\r\n      index++;\r\n    }\r\n    if (jsonString.charAt(index) == '\"') {\r\n      try {\r\n        return JSON.parse(jsonString.substring(start, ++index - Number(escape)));\r\n      } catch (e) {\r\n        throwMalformedError(String(e));\r\n      }\r\n    } else if (Allow.STR & allow) {\r\n      try {\r\n        return JSON.parse(jsonString.substring(start, index - Number(escape)) + '\"');\r\n      } catch (e) {\r\n        // SyntaxError: Invalid escape sequence\r\n        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('\\\\')) + '\"');\r\n      }\r\n    }\r\n    markPartialJSON('Unterminated string literal');\r\n  };\r\n\r\n  const parseObj = () => {\r\n    index++; // skip initial brace\r\n    skipBlank();\r\n    const obj: Record<string, any> = {};\r\n    try {\r\n      while (jsonString[index] !== '}') {\r\n        skipBlank();\r\n        if (index >= length && Allow.OBJ & allow) return obj;\r\n        const key = parseStr();\r\n        skipBlank();\r\n        index++; // skip colon\r\n        try {\r\n          const value = parseAny();\r\n          Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });\r\n        } catch (e) {\r\n          if (Allow.OBJ & allow) return obj;\r\n          else throw e;\r\n        }\r\n        skipBlank();\r\n        if (jsonString[index] === ',') index++; // skip comma\r\n      }\r\n    } catch (e) {\r\n      if (Allow.OBJ & allow) return obj;\r\n      else markPartialJSON(\"Expected '}' at end of object\");\r\n    }\r\n    index++; // skip final brace\r\n    return obj;\r\n  };\r\n\r\n  const parseArr = () => {\r\n    index++; // skip initial bracket\r\n    const arr = [];\r\n    try {\r\n      while (jsonString[index] !== ']') {\r\n        arr.push(parseAny());\r\n        skipBlank();\r\n        if (jsonString[index] === ',') {\r\n          index++; // skip comma\r\n        }\r\n      }\r\n    } catch (e) {\r\n      if (Allow.ARR & allow) {\r\n        return arr;\r\n      }\r\n      markPartialJSON(\"Expected ']' at end of array\");\r\n    }\r\n    index++; // skip final bracket\r\n    return arr;\r\n  };\r\n\r\n  const parseNum = () => {\r\n    if (index === 0) {\r\n      if (jsonString === '-' && Allow.NUM & allow) markPartialJSON(\"Not sure what '-' is\");\r\n      try {\r\n        return JSON.parse(jsonString);\r\n      } catch (e) {\r\n        if (Allow.NUM & allow) {\r\n          try {\r\n            if ('.' === jsonString[jsonString.length - 1])\r\n              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('.')));\r\n            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('e')));\r\n          } catch (e) {}\r\n        }\r\n        throwMalformedError(String(e));\r\n      }\r\n    }\r\n\r\n    const start = index;\r\n\r\n    if (jsonString[index] === '-') index++;\r\n    while (jsonString[index] && !',]}'.includes(jsonString[index]!)) index++;\r\n\r\n    if (index == length && !(Allow.NUM & allow)) markPartialJSON('Unterminated number literal');\r\n\r\n    try {\r\n      return JSON.parse(jsonString.substring(start, index));\r\n    } catch (e) {\r\n      if (jsonString.substring(start, index) === '-' && Allow.NUM & allow)\r\n        markPartialJSON(\"Not sure what '-' is\");\r\n      try {\r\n        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('e')));\r\n      } catch (e) {\r\n        throwMalformedError(String(e));\r\n      }\r\n    }\r\n  };\r\n\r\n  const skipBlank = () => {\r\n    while (index < length && ' \\n\\r\\t'.includes(jsonString[index]!)) {\r\n      index++;\r\n    }\r\n  };\r\n\r\n  return parseAny();\r\n};\r\n\r\n// using this function with malformed JSON is undefined behavior\r\nconst partialParse = (input: string) => parseJSON(input, Allow.ALL ^ Allow.NUM);\r\n\r\nexport { partialParse, PartialJSON, MalformedJSON };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}