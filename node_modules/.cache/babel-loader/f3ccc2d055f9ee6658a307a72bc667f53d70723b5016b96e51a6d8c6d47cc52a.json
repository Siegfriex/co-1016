{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError;\nimport { APIUserAbortError, OpenAIError } from \"../error.mjs\";\nexport class EventStream {\n  constructor() {\n    _EventStream_instances.add(this);\n    this.controller = new AbortController();\n    _EventStream_connectedPromise.set(this, void 0);\n    _EventStream_resolveConnectedPromise.set(this, () => {});\n    _EventStream_rejectConnectedPromise.set(this, () => {});\n    _EventStream_endPromise.set(this, void 0);\n    _EventStream_resolveEndPromise.set(this, () => {});\n    _EventStream_rejectEndPromise.set(this, () => {});\n    _EventStream_listeners.set(this, {});\n    _EventStream_ended.set(this, false);\n    _EventStream_errored.set(this, false);\n    _EventStream_aborted.set(this, false);\n    _EventStream_catchingPromiseCreated.set(this, false);\n    __classPrivateFieldSet(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _EventStream_resolveConnectedPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _EventStream_rejectConnectedPromise, reject, \"f\");\n    }), \"f\");\n    __classPrivateFieldSet(this, _EventStream_endPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _EventStream_resolveEndPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _EventStream_rejectEndPromise, reject, \"f\");\n    }), \"f\");\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    __classPrivateFieldGet(this, _EventStream_connectedPromise, \"f\").catch(() => {});\n    __classPrivateFieldGet(this, _EventStream_endPromise, \"f\").catch(() => {});\n  }\n  _run(executor) {\n    // Unfortunately if we call `executor()` immediately we get runtime errors about\n    // references to `this` before the `super()` constructor call returns.\n    setTimeout(() => {\n      executor().then(() => {\n        this._emitFinal();\n        this._emit('end');\n      }, __classPrivateFieldGet(this, _EventStream_instances, \"m\", _EventStream_handleError).bind(this));\n    }, 0);\n  }\n  _connected() {\n    if (this.ended) return;\n    __classPrivateFieldGet(this, _EventStream_resolveConnectedPromise, \"f\").call(this);\n    this._emit('connect');\n  }\n  get ended() {\n    return __classPrivateFieldGet(this, _EventStream_ended, \"f\");\n  }\n  get errored() {\n    return __classPrivateFieldGet(this, _EventStream_errored, \"f\");\n  }\n  get aborted() {\n    return __classPrivateFieldGet(this, _EventStream_aborted, \"f\");\n  }\n  abort() {\n    this.controller.abort();\n  }\n  /**\r\n   * Adds the listener function to the end of the listeners array for the event.\r\n   * No checks are made to see if the listener has already been added. Multiple calls passing\r\n   * the same combination of event and listener will result in the listener being added, and\r\n   * called, multiple times.\r\n   * @returns this ChatCompletionStream, so that calls can be chained\r\n   */\n  on(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener\n    });\n    return this;\n  }\n  /**\r\n   * Removes the specified listener from the listener array for the event.\r\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\r\n   * listener has been added multiple times to the listener array for the specified event, then\r\n   * off() must be called multiple times to remove each instance.\r\n   * @returns this ChatCompletionStream, so that calls can be chained\r\n   */\n  off(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex(l => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n  /**\r\n   * Adds a one-time listener function for the event. The next time the event is triggered,\r\n   * this listener is removed and then invoked.\r\n   * @returns this ChatCompletionStream, so that calls can be chained\r\n   */\n  once(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener,\n      once: true\n    });\n    return this;\n  }\n  /**\r\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\r\n   * the event is triggered, instead of calling a listener callback.\r\n   * @returns a Promise that resolves the next time given event is triggered,\r\n   * or rejects if an error is emitted.  (If you request the 'error' event,\r\n   * returns a promise that resolves with the error).\r\n   *\r\n   * Example:\r\n   *\r\n   *   const message = await stream.emitted('message') // rejects if the stream errors\r\n   */\n  emitted(event) {\n    return new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, \"f\");\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve);\n    });\n  }\n  async done() {\n    __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, \"f\");\n    await __classPrivateFieldGet(this, _EventStream_endPromise, \"f\");\n  }\n  _emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    // make sure we don't emit any events after end\n    if (__classPrivateFieldGet(this, _EventStream_ended, \"f\")) {\n      return;\n    }\n    if (event === 'end') {\n      __classPrivateFieldSet(this, _EventStream_ended, true, \"f\");\n      __classPrivateFieldGet(this, _EventStream_resolveEndPromise, \"f\").call(this);\n    }\n    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event];\n    if (listeners) {\n      __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = listeners.filter(l => !l.once);\n      listeners.forEach(_ref => {\n        let {\n          listener\n        } = _ref;\n        return listener(...args);\n      });\n    }\n    if (event === 'abort') {\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, \"f\") && !(listeners !== null && listeners !== void 0 && listeners.length)) {\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _EventStream_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n      return;\n    }\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, \"f\") && !(listeners !== null && listeners !== void 0 && listeners.length)) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.finalChatCompletion()\n        // - etc.\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _EventStream_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n    }\n  }\n  _emitFinal() {}\n}\n_EventStream_connectedPromise = new WeakMap(), _EventStream_resolveConnectedPromise = new WeakMap(), _EventStream_rejectConnectedPromise = new WeakMap(), _EventStream_endPromise = new WeakMap(), _EventStream_resolveEndPromise = new WeakMap(), _EventStream_rejectEndPromise = new WeakMap(), _EventStream_listeners = new WeakMap(), _EventStream_ended = new WeakMap(), _EventStream_errored = new WeakMap(), _EventStream_aborted = new WeakMap(), _EventStream_catchingPromiseCreated = new WeakMap(), _EventStream_instances = new WeakSet(), _EventStream_handleError = function _EventStream_handleError(error) {\n  __classPrivateFieldSet(this, _EventStream_errored, true, \"f\");\n  if (error instanceof Error && error.name === 'AbortError') {\n    error = new APIUserAbortError();\n  }\n  if (error instanceof APIUserAbortError) {\n    __classPrivateFieldSet(this, _EventStream_aborted, true, \"f\");\n    return this._emit('abort', error);\n  }\n  if (error instanceof OpenAIError) {\n    return this._emit('error', error);\n  }\n  if (error instanceof Error) {\n    const openAIError = new OpenAIError(error.message);\n    // @ts-ignore\n    openAIError.cause = error;\n    return this._emit('error', openAIError);\n  }\n  return this._emit('error', new OpenAIError(String(error)));\n};","map":{"version":3,"names":["APIUserAbortError","OpenAIError","EventStream","constructor","controller","AbortController","_EventStream_connectedPromise","set","_EventStream_resolveConnectedPromise","_EventStream_rejectConnectedPromise","_EventStream_endPromise","_EventStream_resolveEndPromise","_EventStream_rejectEndPromise","_EventStream_listeners","_EventStream_ended","_EventStream_errored","_EventStream_aborted","_EventStream_catchingPromiseCreated","__classPrivateFieldSet","Promise","resolve","reject","__classPrivateFieldGet","catch","_run","executor","setTimeout","then","_emitFinal","_emit","_EventStream_instances","_EventStream_handleError","bind","_connected","ended","call","errored","aborted","abort","on","event","listener","listeners","push","off","index","findIndex","l","splice","once","emitted","done","_len","arguments","length","args","Array","_key","filter","forEach","_ref","error","Error","name","openAIError","message","cause","String"],"sources":["C:\\co-1016\\node_modules\\openai\\src\\lib\\EventStream.ts"],"sourcesContent":["import { APIUserAbortError, OpenAIError } from '../error';\r\n\r\nexport class EventStream<EventTypes extends BaseEvents> {\r\n  controller: AbortController = new AbortController();\r\n\r\n  #connectedPromise: Promise<void>;\r\n  #resolveConnectedPromise: () => void = () => {};\r\n  #rejectConnectedPromise: (error: OpenAIError) => void = () => {};\r\n\r\n  #endPromise: Promise<void>;\r\n  #resolveEndPromise: () => void = () => {};\r\n  #rejectEndPromise: (error: OpenAIError) => void = () => {};\r\n\r\n  #listeners: {\r\n    [Event in keyof EventTypes]?: EventListeners<EventTypes, Event>;\r\n  } = {};\r\n\r\n  #ended = false;\r\n  #errored = false;\r\n  #aborted = false;\r\n  #catchingPromiseCreated = false;\r\n\r\n  constructor() {\r\n    this.#connectedPromise = new Promise<void>((resolve, reject) => {\r\n      this.#resolveConnectedPromise = resolve;\r\n      this.#rejectConnectedPromise = reject;\r\n    });\r\n\r\n    this.#endPromise = new Promise<void>((resolve, reject) => {\r\n      this.#resolveEndPromise = resolve;\r\n      this.#rejectEndPromise = reject;\r\n    });\r\n\r\n    // Don't let these promises cause unhandled rejection errors.\r\n    // we will manually cause an unhandled rejection error later\r\n    // if the user hasn't registered any error listener or called\r\n    // any promise-returning method.\r\n    this.#connectedPromise.catch(() => {});\r\n    this.#endPromise.catch(() => {});\r\n  }\r\n\r\n  protected _run(this: EventStream<EventTypes>, executor: () => Promise<any>) {\r\n    // Unfortunately if we call `executor()` immediately we get runtime errors about\r\n    // references to `this` before the `super()` constructor call returns.\r\n    setTimeout(() => {\r\n      executor().then(() => {\r\n        this._emitFinal();\r\n        this._emit('end');\r\n      }, this.#handleError.bind(this));\r\n    }, 0);\r\n  }\r\n\r\n  protected _connected(this: EventStream<EventTypes>) {\r\n    if (this.ended) return;\r\n    this.#resolveConnectedPromise();\r\n    this._emit('connect');\r\n  }\r\n\r\n  get ended(): boolean {\r\n    return this.#ended;\r\n  }\r\n\r\n  get errored(): boolean {\r\n    return this.#errored;\r\n  }\r\n\r\n  get aborted(): boolean {\r\n    return this.#aborted;\r\n  }\r\n\r\n  abort() {\r\n    this.controller.abort();\r\n  }\r\n\r\n  /**\r\n   * Adds the listener function to the end of the listeners array for the event.\r\n   * No checks are made to see if the listener has already been added. Multiple calls passing\r\n   * the same combination of event and listener will result in the listener being added, and\r\n   * called, multiple times.\r\n   * @returns this ChatCompletionStream, so that calls can be chained\r\n   */\r\n  on<Event extends keyof EventTypes>(event: Event, listener: EventListener<EventTypes, Event>): this {\r\n    const listeners: EventListeners<EventTypes, Event> =\r\n      this.#listeners[event] || (this.#listeners[event] = []);\r\n    listeners.push({ listener });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes the specified listener from the listener array for the event.\r\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\r\n   * listener has been added multiple times to the listener array for the specified event, then\r\n   * off() must be called multiple times to remove each instance.\r\n   * @returns this ChatCompletionStream, so that calls can be chained\r\n   */\r\n  off<Event extends keyof EventTypes>(event: Event, listener: EventListener<EventTypes, Event>): this {\r\n    const listeners = this.#listeners[event];\r\n    if (!listeners) return this;\r\n    const index = listeners.findIndex((l) => l.listener === listener);\r\n    if (index >= 0) listeners.splice(index, 1);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds a one-time listener function for the event. The next time the event is triggered,\r\n   * this listener is removed and then invoked.\r\n   * @returns this ChatCompletionStream, so that calls can be chained\r\n   */\r\n  once<Event extends keyof EventTypes>(event: Event, listener: EventListener<EventTypes, Event>): this {\r\n    const listeners: EventListeners<EventTypes, Event> =\r\n      this.#listeners[event] || (this.#listeners[event] = []);\r\n    listeners.push({ listener, once: true });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\r\n   * the event is triggered, instead of calling a listener callback.\r\n   * @returns a Promise that resolves the next time given event is triggered,\r\n   * or rejects if an error is emitted.  (If you request the 'error' event,\r\n   * returns a promise that resolves with the error).\r\n   *\r\n   * Example:\r\n   *\r\n   *   const message = await stream.emitted('message') // rejects if the stream errors\r\n   */\r\n  emitted<Event extends keyof EventTypes>(\r\n    event: Event,\r\n  ): Promise<\r\n    EventParameters<EventTypes, Event> extends [infer Param] ? Param\r\n    : EventParameters<EventTypes, Event> extends [] ? void\r\n    : EventParameters<EventTypes, Event>\r\n  > {\r\n    return new Promise((resolve, reject) => {\r\n      this.#catchingPromiseCreated = true;\r\n      if (event !== 'error') this.once('error', reject);\r\n      this.once(event, resolve as any);\r\n    });\r\n  }\r\n\r\n  async done(): Promise<void> {\r\n    this.#catchingPromiseCreated = true;\r\n    await this.#endPromise;\r\n  }\r\n\r\n  #handleError(this: EventStream<EventTypes>, error: unknown) {\r\n    this.#errored = true;\r\n    if (error instanceof Error && error.name === 'AbortError') {\r\n      error = new APIUserAbortError();\r\n    }\r\n    if (error instanceof APIUserAbortError) {\r\n      this.#aborted = true;\r\n      return this._emit('abort', error);\r\n    }\r\n    if (error instanceof OpenAIError) {\r\n      return this._emit('error', error);\r\n    }\r\n    if (error instanceof Error) {\r\n      const openAIError: OpenAIError = new OpenAIError(error.message);\r\n      // @ts-ignore\r\n      openAIError.cause = error;\r\n      return this._emit('error', openAIError);\r\n    }\r\n    return this._emit('error', new OpenAIError(String(error)));\r\n  }\r\n\r\n  _emit<Event extends keyof BaseEvents>(event: Event, ...args: EventParameters<BaseEvents, Event>): void;\r\n  _emit<Event extends keyof EventTypes>(event: Event, ...args: EventParameters<EventTypes, Event>): void;\r\n  _emit<Event extends keyof EventTypes>(\r\n    this: EventStream<EventTypes>,\r\n    event: Event,\r\n    ...args: EventParameters<EventTypes, Event>\r\n  ) {\r\n    // make sure we don't emit any events after end\r\n    if (this.#ended) {\r\n      return;\r\n    }\r\n\r\n    if (event === 'end') {\r\n      this.#ended = true;\r\n      this.#resolveEndPromise();\r\n    }\r\n\r\n    const listeners: EventListeners<EventTypes, Event> | undefined = this.#listeners[event];\r\n    if (listeners) {\r\n      this.#listeners[event] = listeners.filter((l) => !l.once) as any;\r\n      listeners.forEach(({ listener }: any) => listener(...(args as any)));\r\n    }\r\n\r\n    if (event === 'abort') {\r\n      const error = args[0] as APIUserAbortError;\r\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\r\n        Promise.reject(error);\r\n      }\r\n      this.#rejectConnectedPromise(error);\r\n      this.#rejectEndPromise(error);\r\n      this._emit('end');\r\n      return;\r\n    }\r\n\r\n    if (event === 'error') {\r\n      // NOTE: _emit('error', error) should only be called from #handleError().\r\n\r\n      const error = args[0] as OpenAIError;\r\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\r\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\r\n        // If you are seeing stack traces here, make sure to handle errors via either:\r\n        // - runner.on('error', () => ...)\r\n        // - await runner.done()\r\n        // - await runner.finalChatCompletion()\r\n        // - etc.\r\n        Promise.reject(error);\r\n      }\r\n      this.#rejectConnectedPromise(error);\r\n      this.#rejectEndPromise(error);\r\n      this._emit('end');\r\n    }\r\n  }\r\n\r\n  protected _emitFinal(): void {}\r\n}\r\n\r\ntype EventListener<Events, EventType extends keyof Events> = Events[EventType];\r\n\r\ntype EventListeners<Events, EventType extends keyof Events> = Array<{\r\n  listener: EventListener<Events, EventType>;\r\n  once?: boolean;\r\n}>;\r\n\r\nexport type EventParameters<Events, EventType extends keyof Events> = {\r\n  [Event in EventType]: EventListener<Events, EventType> extends (...args: infer P) => any ? P : never;\r\n}[EventType];\r\n\r\nexport interface BaseEvents {\r\n  connect: () => void;\r\n  error: (error: OpenAIError) => void;\r\n  abort: (error: APIUserAbortError) => void;\r\n  end: () => void;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}