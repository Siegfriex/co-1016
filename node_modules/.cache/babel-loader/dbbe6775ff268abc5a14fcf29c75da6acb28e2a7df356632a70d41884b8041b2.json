{"ast":null,"code":"import _objectSpread from \"C:/co-1016/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncIterator from \"C:/co-1016/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { FormData, File, getMultipartRequestOptions, isFsReadStream } from \"./_shims/index.mjs\";\nexport { fileFromPath } from \"./_shims/index.mjs\";\nexport const isResponseLike = value => value != null && typeof value === 'object' && typeof value.url === 'string' && typeof value.blob === 'function';\nexport const isFileLike = value => value != null && typeof value === 'object' && typeof value.name === 'string' && typeof value.lastModified === 'number' && isBlobLike(value);\n/**\r\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\r\n * adds the arrayBuffer() method type because it is available and used at runtime\r\n */\nexport const isBlobLike = value => value != null && typeof value === 'object' && typeof value.size === 'number' && typeof value.type === 'string' && typeof value.text === 'function' && typeof value.slice === 'function' && typeof value.arrayBuffer === 'function';\nexport const isUploadable = value => {\n  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);\n};\n/**\r\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\r\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\r\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\r\n * @param {Object=} options additional properties\r\n * @param {string=} options.type the MIME type of the content\r\n * @param {number=} options.lastModified the last modified timestamp\r\n * @returns a {@link File} with the given properties\r\n */\nexport async function toFile(value, name, options) {\n  var _getName, _options;\n  // If it's a promise, resolve it.\n  value = await value;\n  // If we've been given a `File` we don't need to do anything\n  if (isFileLike(value)) {\n    return value;\n  }\n  if (isResponseLike(value)) {\n    var _URL$pathname$split$p;\n    const blob = await value.blob();\n    name || (name = (_URL$pathname$split$p = new URL(value.url).pathname.split(/[\\\\/]/).pop()) !== null && _URL$pathname$split$p !== void 0 ? _URL$pathname$split$p : 'unknown_file');\n    // we need to convert the `Blob` into an array buffer because the `Blob` class\n    // that `node-fetch` defines is incompatible with the web standard which results\n    // in `new File` interpreting it as a string instead of binary data.\n    const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];\n    return new File(data, name, options);\n  }\n  const bits = await getBytes(value);\n  name || (name = (_getName = getName(value)) !== null && _getName !== void 0 ? _getName : 'unknown_file');\n  if (!((_options = options) !== null && _options !== void 0 && _options.type)) {\n    var _bits$;\n    const type = (_bits$ = bits[0]) === null || _bits$ === void 0 ? void 0 : _bits$.type;\n    if (typeof type === 'string') {\n      options = _objectSpread(_objectSpread({}, options), {}, {\n        type\n      });\n    }\n  }\n  return new File(bits, name, options);\n}\nasync function getBytes(value) {\n  let parts = [];\n  if (typeof value === 'string' || ArrayBuffer.isView(value) ||\n  // includes Uint8Array, Buffer, etc.\n  value instanceof ArrayBuffer) {\n    parts.push(value);\n  } else if (isBlobLike(value)) {\n    parts.push(await value.arrayBuffer());\n  } else if (isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\n  ) {\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(value), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n        const chunk = _step.value;\n        {\n          parts.push(chunk); // TODO, consider validating?\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } else {\n    var _value$constructor;\n    throw new Error(\"Unexpected data type: \".concat(typeof value, \"; constructor: \").concat(value === null || value === void 0 || (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name, \"; props: \").concat(propsForError(value)));\n  }\n  return parts;\n}\nfunction propsForError(value) {\n  const props = Object.getOwnPropertyNames(value);\n  return \"[\".concat(props.map(p => \"\\\"\".concat(p, \"\\\"\")).join(', '), \"]\");\n}\nfunction getName(value) {\n  var _getStringFromMaybeBu;\n  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || (// For fs.ReadStream\n  (_getStringFromMaybeBu = getStringFromMaybeBuffer(value.path)) === null || _getStringFromMaybeBu === void 0 ? void 0 : _getStringFromMaybeBu.split(/[\\\\/]/).pop());\n}\nconst getStringFromMaybeBuffer = x => {\n  if (typeof x === 'string') return x;\n  if (typeof Buffer !== 'undefined' && x instanceof Buffer) return String(x);\n  return undefined;\n};\nconst isAsyncIterableIterator = value => value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\nexport const isMultipartBody = body => body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\n/**\r\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\r\n * Otherwise returns the request as is.\r\n */\nexport const maybeMultipartFormRequestOptions = async opts => {\n  if (!hasUploadableValue(opts.body)) return opts;\n  const form = await createForm(opts.body);\n  return getMultipartRequestOptions(form, opts);\n};\nexport const multipartFormRequestOptions = async opts => {\n  const form = await createForm(opts.body);\n  return getMultipartRequestOptions(form, opts);\n};\nexport const createForm = async body => {\n  const form = new FormData();\n  await Promise.all(Object.entries(body || {}).map(_ref => {\n    let [key, value] = _ref;\n    return addFormValue(form, key, value);\n  }));\n  return form;\n};\nconst hasUploadableValue = value => {\n  if (isUploadable(value)) return true;\n  if (Array.isArray(value)) return value.some(hasUploadableValue);\n  if (value && typeof value === 'object') {\n    for (const k in value) {\n      if (hasUploadableValue(value[k])) return true;\n    }\n  }\n  return false;\n};\nconst addFormValue = async (form, key, value) => {\n  if (value === undefined) return;\n  if (value == null) {\n    throw new TypeError(\"Received null for \\\"\".concat(key, \"\\\"; to pass null in FormData, you must use the string 'null'\"));\n  }\n  // TODO: make nested formats configurable\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    form.append(key, String(value));\n  } else if (isUploadable(value)) {\n    const file = await toFile(value);\n    form.append(key, file);\n  } else if (Array.isArray(value)) {\n    await Promise.all(value.map(entry => addFormValue(form, key + '[]', entry)));\n  } else if (typeof value === 'object') {\n    await Promise.all(Object.entries(value).map(_ref2 => {\n      let [name, prop] = _ref2;\n      return addFormValue(form, \"\".concat(key, \"[\").concat(name, \"]\"), prop);\n    }));\n  } else {\n    throw new TypeError(\"Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got \".concat(value, \" instead\"));\n  }\n};","map":{"version":3,"names":["FormData","File","getMultipartRequestOptions","isFsReadStream","fileFromPath","isResponseLike","value","url","blob","isFileLike","name","lastModified","isBlobLike","size","type","text","slice","arrayBuffer","isUploadable","toFile","options","_getName","_options","_URL$pathname$split$p","URL","pathname","split","pop","data","bits","getBytes","getName","_bits$","_objectSpread","parts","ArrayBuffer","isView","push","isAsyncIterableIterator","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","_step","next","done","chunk","err","return","_value$constructor","Error","concat","constructor","propsForError","props","Object","getOwnPropertyNames","map","p","join","_getStringFromMaybeBu","getStringFromMaybeBuffer","filename","path","x","Buffer","String","undefined","Symbol","asyncIterator","isMultipartBody","body","toStringTag","maybeMultipartFormRequestOptions","opts","hasUploadableValue","form","createForm","multipartFormRequestOptions","Promise","all","entries","_ref","key","addFormValue","Array","isArray","some","k","TypeError","append","file","entry","_ref2","prop"],"sources":["C:\\co-1016\\node_modules\\openai\\src\\uploads.ts"],"sourcesContent":["import { type RequestOptions } from './core';\r\nimport {\r\n  FormData,\r\n  File,\r\n  type Blob,\r\n  type FilePropertyBag,\r\n  getMultipartRequestOptions,\r\n  type FsReadStream,\r\n  isFsReadStream,\r\n} from './_shims/index';\r\nimport { MultipartBody } from './_shims/MultipartBody';\r\nexport { fileFromPath } from './_shims/index';\r\n\r\ntype BlobLikePart = string | ArrayBuffer | ArrayBufferView | BlobLike | Uint8Array | DataView;\r\nexport type BlobPart = string | ArrayBuffer | ArrayBufferView | Blob | Uint8Array | DataView;\r\n\r\n/**\r\n * Typically, this is a native \"File\" class.\r\n *\r\n * We provide the {@link toFile} utility to convert a variety of objects\r\n * into the File class.\r\n *\r\n * For convenience, you can also pass a fetch Response, or in Node,\r\n * the result of fs.createReadStream().\r\n */\r\nexport type Uploadable = FileLike | ResponseLike | FsReadStream;\r\n\r\n/**\r\n * Intended to match web.Blob, node.Blob, node-fetch.Blob, etc.\r\n */\r\nexport interface BlobLike {\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/size) */\r\n  readonly size: number;\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/type) */\r\n  readonly type: string;\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/text) */\r\n  text(): Promise<string>;\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/slice) */\r\n  slice(start?: number, end?: number): BlobLike;\r\n  // unfortunately @types/node-fetch@^2.6.4 doesn't type the arrayBuffer method\r\n}\r\n\r\n/**\r\n * Intended to match web.File, node.File, node-fetch.File, etc.\r\n */\r\nexport interface FileLike extends BlobLike {\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/lastModified) */\r\n  readonly lastModified: number;\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/name) */\r\n  readonly name: string;\r\n}\r\n\r\n/**\r\n * Intended to match web.Response, node.Response, node-fetch.Response, etc.\r\n */\r\nexport interface ResponseLike {\r\n  url: string;\r\n  blob(): Promise<BlobLike>;\r\n}\r\n\r\nexport const isResponseLike = (value: any): value is ResponseLike =>\r\n  value != null &&\r\n  typeof value === 'object' &&\r\n  typeof value.url === 'string' &&\r\n  typeof value.blob === 'function';\r\n\r\nexport const isFileLike = (value: any): value is FileLike =>\r\n  value != null &&\r\n  typeof value === 'object' &&\r\n  typeof value.name === 'string' &&\r\n  typeof value.lastModified === 'number' &&\r\n  isBlobLike(value);\r\n\r\n/**\r\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\r\n * adds the arrayBuffer() method type because it is available and used at runtime\r\n */\r\nexport const isBlobLike = (value: any): value is BlobLike & { arrayBuffer(): Promise<ArrayBuffer> } =>\r\n  value != null &&\r\n  typeof value === 'object' &&\r\n  typeof value.size === 'number' &&\r\n  typeof value.type === 'string' &&\r\n  typeof value.text === 'function' &&\r\n  typeof value.slice === 'function' &&\r\n  typeof value.arrayBuffer === 'function';\r\n\r\nexport const isUploadable = (value: any): value is Uploadable => {\r\n  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);\r\n};\r\n\r\nexport type ToFileInput = Uploadable | Exclude<BlobLikePart, string> | AsyncIterable<BlobLikePart>;\r\n\r\n/**\r\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\r\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\r\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\r\n * @param {Object=} options additional properties\r\n * @param {string=} options.type the MIME type of the content\r\n * @param {number=} options.lastModified the last modified timestamp\r\n * @returns a {@link File} with the given properties\r\n */\r\nexport async function toFile(\r\n  value: ToFileInput | PromiseLike<ToFileInput>,\r\n  name?: string | null | undefined,\r\n  options?: FilePropertyBag | undefined,\r\n): Promise<FileLike> {\r\n  // If it's a promise, resolve it.\r\n  value = await value;\r\n\r\n  // If we've been given a `File` we don't need to do anything\r\n  if (isFileLike(value)) {\r\n    return value;\r\n  }\r\n\r\n  if (isResponseLike(value)) {\r\n    const blob = await value.blob();\r\n    name ||= new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file';\r\n\r\n    // we need to convert the `Blob` into an array buffer because the `Blob` class\r\n    // that `node-fetch` defines is incompatible with the web standard which results\r\n    // in `new File` interpreting it as a string instead of binary data.\r\n    const data = isBlobLike(blob) ? [(await blob.arrayBuffer()) as any] : [blob];\r\n\r\n    return new File(data, name, options);\r\n  }\r\n\r\n  const bits = await getBytes(value);\r\n\r\n  name ||= getName(value) ?? 'unknown_file';\r\n\r\n  if (!options?.type) {\r\n    const type = (bits[0] as any)?.type;\r\n    if (typeof type === 'string') {\r\n      options = { ...options, type };\r\n    }\r\n  }\r\n\r\n  return new File(bits, name, options);\r\n}\r\n\r\nasync function getBytes(value: ToFileInput): Promise<Array<BlobPart>> {\r\n  let parts: Array<BlobPart> = [];\r\n  if (\r\n    typeof value === 'string' ||\r\n    ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\r\n    value instanceof ArrayBuffer\r\n  ) {\r\n    parts.push(value);\r\n  } else if (isBlobLike(value)) {\r\n    parts.push(await value.arrayBuffer());\r\n  } else if (\r\n    isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\r\n  ) {\r\n    for await (const chunk of value) {\r\n      parts.push(chunk as BlobPart); // TODO, consider validating?\r\n    }\r\n  } else {\r\n    throw new Error(\r\n      `Unexpected data type: ${typeof value}; constructor: ${value?.constructor\r\n        ?.name}; props: ${propsForError(value)}`,\r\n    );\r\n  }\r\n\r\n  return parts;\r\n}\r\n\r\nfunction propsForError(value: any): string {\r\n  const props = Object.getOwnPropertyNames(value);\r\n  return `[${props.map((p) => `\"${p}\"`).join(', ')}]`;\r\n}\r\n\r\nfunction getName(value: any): string | undefined {\r\n  return (\r\n    getStringFromMaybeBuffer(value.name) ||\r\n    getStringFromMaybeBuffer(value.filename) ||\r\n    // For fs.ReadStream\r\n    getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop()\r\n  );\r\n}\r\n\r\nconst getStringFromMaybeBuffer = (x: string | Buffer | unknown): string | undefined => {\r\n  if (typeof x === 'string') return x;\r\n  if (typeof Buffer !== 'undefined' && x instanceof Buffer) return String(x);\r\n  return undefined;\r\n};\r\n\r\nconst isAsyncIterableIterator = (value: any): value is AsyncIterableIterator<unknown> =>\r\n  value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\r\n\r\nexport const isMultipartBody = (body: any): body is MultipartBody =>\r\n  body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\r\n\r\n/**\r\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\r\n * Otherwise returns the request as is.\r\n */\r\nexport const maybeMultipartFormRequestOptions = async <T = Record<string, unknown>>(\r\n  opts: RequestOptions<T>,\r\n): Promise<RequestOptions<T | MultipartBody>> => {\r\n  if (!hasUploadableValue(opts.body)) return opts;\r\n\r\n  const form = await createForm(opts.body);\r\n  return getMultipartRequestOptions(form, opts);\r\n};\r\n\r\nexport const multipartFormRequestOptions = async <T = Record<string, unknown>>(\r\n  opts: RequestOptions<T>,\r\n): Promise<RequestOptions<T | MultipartBody>> => {\r\n  const form = await createForm(opts.body);\r\n  return getMultipartRequestOptions(form, opts);\r\n};\r\n\r\nexport const createForm = async <T = Record<string, unknown>>(body: T | undefined): Promise<FormData> => {\r\n  const form = new FormData();\r\n  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\r\n  return form;\r\n};\r\n\r\nconst hasUploadableValue = (value: unknown): boolean => {\r\n  if (isUploadable(value)) return true;\r\n  if (Array.isArray(value)) return value.some(hasUploadableValue);\r\n  if (value && typeof value === 'object') {\r\n    for (const k in value) {\r\n      if (hasUploadableValue((value as any)[k])) return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nconst addFormValue = async (form: FormData, key: string, value: unknown): Promise<void> => {\r\n  if (value === undefined) return;\r\n  if (value == null) {\r\n    throw new TypeError(\r\n      `Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`,\r\n    );\r\n  }\r\n\r\n  // TODO: make nested formats configurable\r\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\r\n    form.append(key, String(value));\r\n  } else if (isUploadable(value)) {\r\n    const file = await toFile(value);\r\n    form.append(key, file as File);\r\n  } else if (Array.isArray(value)) {\r\n    await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\r\n  } else if (typeof value === 'object') {\r\n    await Promise.all(\r\n      Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)),\r\n    );\r\n  } else {\r\n    throw new TypeError(\r\n      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`,\r\n    );\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}