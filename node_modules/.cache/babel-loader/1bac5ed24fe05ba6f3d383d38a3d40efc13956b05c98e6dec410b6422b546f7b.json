{"ast":null,"code":"import _objectSpread from \"C:/co-1016/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { ContentFilterFinishReasonError, LengthFinishReasonError, OpenAIError } from \"../error.mjs\";\nexport function makeParseableResponseFormat(response_format, parser) {\n  const obj = _objectSpread({}, response_format);\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-response-format',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nexport function makeParseableTextFormat(response_format, parser) {\n  const obj = _objectSpread({}, response_format);\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-response-format',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nexport function isAutoParsableResponseFormat(response_format) {\n  return (response_format === null || response_format === void 0 ? void 0 : response_format['$brand']) === 'auto-parseable-response-format';\n}\nexport function makeParseableTool(tool, _ref) {\n  let {\n    parser,\n    callback\n  } = _ref;\n  const obj = _objectSpread({}, tool);\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-tool',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    },\n    $callback: {\n      value: callback,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nexport function isAutoParsableTool(tool) {\n  return (tool === null || tool === void 0 ? void 0 : tool['$brand']) === 'auto-parseable-tool';\n}\nexport function maybeParseChatCompletion(completion, params) {\n  if (!params || !hasAutoParseableInput(params)) {\n    return _objectSpread(_objectSpread({}, completion), {}, {\n      choices: completion.choices.map(choice => _objectSpread(_objectSpread({}, choice), {}, {\n        message: _objectSpread(_objectSpread({}, choice.message), {}, {\n          parsed: null\n        }, choice.message.tool_calls ? {\n          tool_calls: choice.message.tool_calls\n        } : undefined)\n      }))\n    });\n  }\n  return parseChatCompletion(completion, params);\n}\nexport function parseChatCompletion(completion, params) {\n  const choices = completion.choices.map(choice => {\n    var _choice$message$tool_, _choice$message$tool_2;\n    if (choice.finish_reason === 'length') {\n      throw new LengthFinishReasonError();\n    }\n    if (choice.finish_reason === 'content_filter') {\n      throw new ContentFilterFinishReasonError();\n    }\n    return _objectSpread(_objectSpread({}, choice), {}, {\n      message: _objectSpread(_objectSpread(_objectSpread({}, choice.message), choice.message.tool_calls ? {\n        tool_calls: (_choice$message$tool_ = (_choice$message$tool_2 = choice.message.tool_calls) === null || _choice$message$tool_2 === void 0 ? void 0 : _choice$message$tool_2.map(toolCall => parseToolCall(params, toolCall))) !== null && _choice$message$tool_ !== void 0 ? _choice$message$tool_ : undefined\n      } : undefined), {}, {\n        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null\n      })\n    });\n  });\n  return _objectSpread(_objectSpread({}, completion), {}, {\n    choices\n  });\n}\nfunction parseResponseFormat(params, content) {\n  var _params$response_form, _params$response_form2;\n  if (((_params$response_form = params.response_format) === null || _params$response_form === void 0 ? void 0 : _params$response_form.type) !== 'json_schema') {\n    return null;\n  }\n  if (((_params$response_form2 = params.response_format) === null || _params$response_form2 === void 0 ? void 0 : _params$response_form2.type) === 'json_schema') {\n    if ('$parseRaw' in params.response_format) {\n      const response_format = params.response_format;\n      return response_format.$parseRaw(content);\n    }\n    return JSON.parse(content);\n  }\n  return null;\n}\nfunction parseToolCall(params, toolCall) {\n  var _params$tools;\n  const inputTool = (_params$tools = params.tools) === null || _params$tools === void 0 ? void 0 : _params$tools.find(inputTool => {\n    var _inputTool$function;\n    return ((_inputTool$function = inputTool.function) === null || _inputTool$function === void 0 ? void 0 : _inputTool$function.name) === toolCall.function.name;\n  });\n  return _objectSpread(_objectSpread({}, toolCall), {}, {\n    function: _objectSpread(_objectSpread({}, toolCall.function), {}, {\n      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : inputTool !== null && inputTool !== void 0 && inputTool.function.strict ? JSON.parse(toolCall.function.arguments) : null\n    })\n  });\n}\nexport function shouldParseToolCall(params, toolCall) {\n  var _params$tools2;\n  if (!params) {\n    return false;\n  }\n  const inputTool = (_params$tools2 = params.tools) === null || _params$tools2 === void 0 ? void 0 : _params$tools2.find(inputTool => {\n    var _inputTool$function2;\n    return ((_inputTool$function2 = inputTool.function) === null || _inputTool$function2 === void 0 ? void 0 : _inputTool$function2.name) === toolCall.function.name;\n  });\n  return isAutoParsableTool(inputTool) || (inputTool === null || inputTool === void 0 ? void 0 : inputTool.function.strict) || false;\n}\nexport function hasAutoParseableInput(params) {\n  var _params$tools$some, _params$tools3;\n  if (isAutoParsableResponseFormat(params.response_format)) {\n    return true;\n  }\n  return (_params$tools$some = (_params$tools3 = params.tools) === null || _params$tools3 === void 0 ? void 0 : _params$tools3.some(t => isAutoParsableTool(t) || t.type === 'function' && t.function.strict === true)) !== null && _params$tools$some !== void 0 ? _params$tools$some : false;\n}\nexport function validateInputTools(tools) {\n  for (const tool of tools !== null && tools !== void 0 ? tools : []) {\n    if (tool.type !== 'function') {\n      throw new OpenAIError(\"Currently only `function` tool types support auto-parsing; Received `\".concat(tool.type, \"`\"));\n    }\n    if (tool.function.strict !== true) {\n      throw new OpenAIError(\"The `\".concat(tool.function.name, \"` tool is not marked with `strict: true`. Only strict function tools can be auto-parsed\"));\n    }\n  }\n}","map":{"version":3,"names":["ContentFilterFinishReasonError","LengthFinishReasonError","OpenAIError","makeParseableResponseFormat","response_format","parser","obj","_objectSpread","Object","defineProperties","$brand","value","enumerable","$parseRaw","makeParseableTextFormat","isAutoParsableResponseFormat","makeParseableTool","tool","_ref","callback","$callback","isAutoParsableTool","maybeParseChatCompletion","completion","params","hasAutoParseableInput","choices","map","choice","message","parsed","tool_calls","undefined","parseChatCompletion","_choice$message$tool_","_choice$message$tool_2","finish_reason","toolCall","parseToolCall","content","refusal","parseResponseFormat","_params$response_form","_params$response_form2","type","JSON","parse","_params$tools","inputTool","tools","find","_inputTool$function","function","name","parsed_arguments","arguments","strict","shouldParseToolCall","_params$tools2","_inputTool$function2","_params$tools$some","_params$tools3","some","t","validateInputTools","concat"],"sources":["C:\\co-1016\\node_modules\\openai\\src\\lib\\parser.ts"],"sourcesContent":["import {\r\n  ChatCompletion,\r\n  ChatCompletionCreateParams,\r\n  ChatCompletionMessageToolCall,\r\n  ChatCompletionTool,\r\n} from '../resources/chat/completions';\r\nimport {\r\n  ChatCompletionStreamingToolRunnerParams,\r\n  ChatCompletionStreamParams,\r\n  ChatCompletionToolRunnerParams,\r\n  ParsedChatCompletion,\r\n  ParsedChoice,\r\n  ParsedFunctionToolCall,\r\n} from '../resources/beta/chat/completions';\r\nimport { ResponseFormatJSONSchema } from '../resources/shared';\r\nimport { ContentFilterFinishReasonError, LengthFinishReasonError, OpenAIError } from '../error';\r\nimport { type ResponseFormatTextJSONSchemaConfig } from '../resources/responses/responses';\r\n\r\ntype AnyChatCompletionCreateParams =\r\n  | ChatCompletionCreateParams\r\n  | ChatCompletionToolRunnerParams<any>\r\n  | ChatCompletionStreamingToolRunnerParams<any>\r\n  | ChatCompletionStreamParams;\r\n\r\nexport type ExtractParsedContentFromParams<Params extends AnyChatCompletionCreateParams> =\r\n  Params['response_format'] extends AutoParseableResponseFormat<infer P> ? P : null;\r\n\r\nexport type AutoParseableResponseFormat<ParsedT> = ResponseFormatJSONSchema & {\r\n  __output: ParsedT; // type-level only\r\n\r\n  $brand: 'auto-parseable-response-format';\r\n  $parseRaw(content: string): ParsedT;\r\n};\r\n\r\nexport function makeParseableResponseFormat<ParsedT>(\r\n  response_format: ResponseFormatJSONSchema,\r\n  parser: (content: string) => ParsedT,\r\n): AutoParseableResponseFormat<ParsedT> {\r\n  const obj = { ...response_format };\r\n\r\n  Object.defineProperties(obj, {\r\n    $brand: {\r\n      value: 'auto-parseable-response-format',\r\n      enumerable: false,\r\n    },\r\n    $parseRaw: {\r\n      value: parser,\r\n      enumerable: false,\r\n    },\r\n  });\r\n\r\n  return obj as AutoParseableResponseFormat<ParsedT>;\r\n}\r\n\r\nexport type AutoParseableTextFormat<ParsedT> = ResponseFormatTextJSONSchemaConfig & {\r\n  __output: ParsedT; // type-level only\r\n\r\n  $brand: 'auto-parseable-response-format';\r\n  $parseRaw(content: string): ParsedT;\r\n};\r\n\r\nexport function makeParseableTextFormat<ParsedT>(\r\n  response_format: ResponseFormatTextJSONSchemaConfig,\r\n  parser: (content: string) => ParsedT,\r\n): AutoParseableTextFormat<ParsedT> {\r\n  const obj = { ...response_format };\r\n\r\n  Object.defineProperties(obj, {\r\n    $brand: {\r\n      value: 'auto-parseable-response-format',\r\n      enumerable: false,\r\n    },\r\n    $parseRaw: {\r\n      value: parser,\r\n      enumerable: false,\r\n    },\r\n  });\r\n\r\n  return obj as AutoParseableTextFormat<ParsedT>;\r\n}\r\n\r\nexport function isAutoParsableResponseFormat<ParsedT>(\r\n  response_format: any,\r\n): response_format is AutoParseableResponseFormat<ParsedT> {\r\n  return response_format?.['$brand'] === 'auto-parseable-response-format';\r\n}\r\n\r\ntype ToolOptions = {\r\n  name: string;\r\n  arguments: any;\r\n  function?: ((args: any) => any) | undefined;\r\n};\r\n\r\nexport type AutoParseableTool<\r\n  OptionsT extends ToolOptions,\r\n  HasFunction = OptionsT['function'] extends Function ? true : false,\r\n> = ChatCompletionTool & {\r\n  __arguments: OptionsT['arguments']; // type-level only\r\n  __name: OptionsT['name']; // type-level only\r\n  __hasFunction: HasFunction; // type-level only\r\n\r\n  $brand: 'auto-parseable-tool';\r\n  $callback: ((args: OptionsT['arguments']) => any) | undefined;\r\n  $parseRaw(args: string): OptionsT['arguments'];\r\n};\r\n\r\nexport function makeParseableTool<OptionsT extends ToolOptions>(\r\n  tool: ChatCompletionTool,\r\n  {\r\n    parser,\r\n    callback,\r\n  }: {\r\n    parser: (content: string) => OptionsT['arguments'];\r\n    callback: ((args: any) => any) | undefined;\r\n  },\r\n): AutoParseableTool<OptionsT['arguments']> {\r\n  const obj = { ...tool };\r\n\r\n  Object.defineProperties(obj, {\r\n    $brand: {\r\n      value: 'auto-parseable-tool',\r\n      enumerable: false,\r\n    },\r\n    $parseRaw: {\r\n      value: parser,\r\n      enumerable: false,\r\n    },\r\n    $callback: {\r\n      value: callback,\r\n      enumerable: false,\r\n    },\r\n  });\r\n\r\n  return obj as AutoParseableTool<OptionsT['arguments']>;\r\n}\r\n\r\nexport function isAutoParsableTool(tool: any): tool is AutoParseableTool<any> {\r\n  return tool?.['$brand'] === 'auto-parseable-tool';\r\n}\r\n\r\nexport function maybeParseChatCompletion<\r\n  Params extends ChatCompletionCreateParams | null,\r\n  ParsedT = Params extends null ? null : ExtractParsedContentFromParams<NonNullable<Params>>,\r\n>(completion: ChatCompletion, params: Params): ParsedChatCompletion<ParsedT> {\r\n  if (!params || !hasAutoParseableInput(params)) {\r\n    return {\r\n      ...completion,\r\n      choices: completion.choices.map((choice) => ({\r\n        ...choice,\r\n        message: {\r\n          ...choice.message,\r\n          parsed: null,\r\n          ...(choice.message.tool_calls ?\r\n            {\r\n              tool_calls: choice.message.tool_calls,\r\n            }\r\n          : undefined),\r\n        },\r\n      })),\r\n    };\r\n  }\r\n\r\n  return parseChatCompletion(completion, params);\r\n}\r\n\r\nexport function parseChatCompletion<\r\n  Params extends ChatCompletionCreateParams,\r\n  ParsedT = ExtractParsedContentFromParams<Params>,\r\n>(completion: ChatCompletion, params: Params): ParsedChatCompletion<ParsedT> {\r\n  const choices: Array<ParsedChoice<ParsedT>> = completion.choices.map((choice): ParsedChoice<ParsedT> => {\r\n    if (choice.finish_reason === 'length') {\r\n      throw new LengthFinishReasonError();\r\n    }\r\n\r\n    if (choice.finish_reason === 'content_filter') {\r\n      throw new ContentFilterFinishReasonError();\r\n    }\r\n\r\n    return {\r\n      ...choice,\r\n      message: {\r\n        ...choice.message,\r\n        ...(choice.message.tool_calls ?\r\n          {\r\n            tool_calls:\r\n              choice.message.tool_calls?.map((toolCall) => parseToolCall(params, toolCall)) ?? undefined,\r\n          }\r\n        : undefined),\r\n        parsed:\r\n          choice.message.content && !choice.message.refusal ?\r\n            parseResponseFormat(params, choice.message.content)\r\n          : null,\r\n      },\r\n    };\r\n  });\r\n\r\n  return { ...completion, choices };\r\n}\r\n\r\nfunction parseResponseFormat<\r\n  Params extends ChatCompletionCreateParams,\r\n  ParsedT = ExtractParsedContentFromParams<Params>,\r\n>(params: Params, content: string): ParsedT | null {\r\n  if (params.response_format?.type !== 'json_schema') {\r\n    return null;\r\n  }\r\n\r\n  if (params.response_format?.type === 'json_schema') {\r\n    if ('$parseRaw' in params.response_format) {\r\n      const response_format = params.response_format as AutoParseableResponseFormat<ParsedT>;\r\n\r\n      return response_format.$parseRaw(content);\r\n    }\r\n\r\n    return JSON.parse(content);\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction parseToolCall<Params extends ChatCompletionCreateParams>(\r\n  params: Params,\r\n  toolCall: ChatCompletionMessageToolCall,\r\n): ParsedFunctionToolCall {\r\n  const inputTool = params.tools?.find((inputTool) => inputTool.function?.name === toolCall.function.name);\r\n  return {\r\n    ...toolCall,\r\n    function: {\r\n      ...toolCall.function,\r\n      parsed_arguments:\r\n        isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments)\r\n        : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments)\r\n        : null,\r\n    },\r\n  };\r\n}\r\n\r\nexport function shouldParseToolCall(\r\n  params: ChatCompletionCreateParams | null | undefined,\r\n  toolCall: ChatCompletionMessageToolCall,\r\n): boolean {\r\n  if (!params) {\r\n    return false;\r\n  }\r\n\r\n  const inputTool = params.tools?.find((inputTool) => inputTool.function?.name === toolCall.function.name);\r\n  return isAutoParsableTool(inputTool) || inputTool?.function.strict || false;\r\n}\r\n\r\nexport function hasAutoParseableInput(params: AnyChatCompletionCreateParams): boolean {\r\n  if (isAutoParsableResponseFormat(params.response_format)) {\r\n    return true;\r\n  }\r\n\r\n  return (\r\n    params.tools?.some(\r\n      (t) => isAutoParsableTool(t) || (t.type === 'function' && t.function.strict === true),\r\n    ) ?? false\r\n  );\r\n}\r\n\r\nexport function validateInputTools(tools: ChatCompletionTool[] | undefined) {\r\n  for (const tool of tools ?? []) {\r\n    if (tool.type !== 'function') {\r\n      throw new OpenAIError(\r\n        `Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``,\r\n      );\r\n    }\r\n\r\n    if (tool.function.strict !== true) {\r\n      throw new OpenAIError(\r\n        `The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`,\r\n      );\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}