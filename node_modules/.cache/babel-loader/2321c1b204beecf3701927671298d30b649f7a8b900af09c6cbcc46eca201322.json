{"ast":null,"code":"import _objectSpread from \"C:/co-1016/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncIterator from \"C:/co-1016/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _AssistantStream_instances, _AssistantStream_events, _AssistantStream_runStepSnapshots, _AssistantStream_messageSnapshots, _AssistantStream_messageSnapshot, _AssistantStream_finalRun, _AssistantStream_currentContentIndex, _AssistantStream_currentContent, _AssistantStream_currentToolCallIndex, _AssistantStream_currentToolCall, _AssistantStream_currentEvent, _AssistantStream_currentRunSnapshot, _AssistantStream_currentRunStepSnapshot, _AssistantStream_addEvent, _AssistantStream_endRequest, _AssistantStream_handleMessage, _AssistantStream_handleRunStep, _AssistantStream_handleEvent, _AssistantStream_accumulateRunStep, _AssistantStream_accumulateMessage, _AssistantStream_accumulateContent, _AssistantStream_handleRun;\nimport * as Core from \"../core.mjs\";\nimport { Stream } from \"../streaming.mjs\";\nimport { APIUserAbortError, OpenAIError } from \"../error.mjs\";\nimport { EventStream } from \"./EventStream.mjs\";\nexport class AssistantStream extends EventStream {\n  constructor() {\n    super(...arguments);\n    _AssistantStream_instances.add(this);\n    //Track all events in a single list for reference\n    _AssistantStream_events.set(this, []);\n    //Used to accumulate deltas\n    //We are accumulating many types so the value here is not strict\n    _AssistantStream_runStepSnapshots.set(this, {});\n    _AssistantStream_messageSnapshots.set(this, {});\n    _AssistantStream_messageSnapshot.set(this, void 0);\n    _AssistantStream_finalRun.set(this, void 0);\n    _AssistantStream_currentContentIndex.set(this, void 0);\n    _AssistantStream_currentContent.set(this, void 0);\n    _AssistantStream_currentToolCallIndex.set(this, void 0);\n    _AssistantStream_currentToolCall.set(this, void 0);\n    //For current snapshot methods\n    _AssistantStream_currentEvent.set(this, void 0);\n    _AssistantStream_currentRunSnapshot.set(this, void 0);\n    _AssistantStream_currentRunStepSnapshot.set(this, void 0);\n  }\n  [(_AssistantStream_events = new WeakMap(), _AssistantStream_runStepSnapshots = new WeakMap(), _AssistantStream_messageSnapshots = new WeakMap(), _AssistantStream_messageSnapshot = new WeakMap(), _AssistantStream_finalRun = new WeakMap(), _AssistantStream_currentContentIndex = new WeakMap(), _AssistantStream_currentContent = new WeakMap(), _AssistantStream_currentToolCallIndex = new WeakMap(), _AssistantStream_currentToolCall = new WeakMap(), _AssistantStream_currentEvent = new WeakMap(), _AssistantStream_currentRunSnapshot = new WeakMap(), _AssistantStream_currentRunStepSnapshot = new WeakMap(), _AssistantStream_instances = new WeakSet(), Symbol.asyncIterator)]() {\n    const pushQueue = [];\n    const readQueue = [];\n    let done = false;\n    //Catch all for passing along all events\n    this.on('event', event => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(event);\n      } else {\n        pushQueue.push(event);\n      }\n    });\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n    this.on('abort', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    this.on('error', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    return {\n      next: async () => {\n        if (!pushQueue.length) {\n          if (done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          return new Promise((resolve, reject) => readQueue.push({\n            resolve,\n            reject\n          })).then(chunk => chunk ? {\n            value: chunk,\n            done: false\n          } : {\n            value: undefined,\n            done: true\n          });\n        }\n        const chunk = pushQueue.shift();\n        return {\n          value: chunk,\n          done: false\n        };\n      },\n      return: async () => {\n        this.abort();\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  static fromReadableStream(stream) {\n    const runner = new AssistantStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n  async _fromReadableStream(readableStream, options) {\n    var _stream$controller$si;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this._connected();\n    const stream = Stream.fromReadableStream(readableStream, this.controller);\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(stream), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n        const event = _step.value;\n        {\n          __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    if ((_stream$controller$si = stream.controller.signal) !== null && _stream$controller$si !== void 0 && _stream$controller$si.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n  }\n  toReadableStream() {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n  static createToolAssistantStream(threadId, runId, runs, params, options) {\n    const runner = new AssistantStream();\n    runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, _objectSpread(_objectSpread({}, options), {}, {\n      headers: _objectSpread(_objectSpread({}, options === null || options === void 0 ? void 0 : options.headers), {}, {\n        'X-Stainless-Helper-Method': 'stream'\n      })\n    })));\n    return runner;\n  }\n  async _createToolAssistantStream(run, threadId, runId, params, options) {\n    var _stream$controller$si2;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    const body = _objectSpread(_objectSpread({}, params), {}, {\n      stream: true\n    });\n    const stream = await run.submitToolOutputs(threadId, runId, body, _objectSpread(_objectSpread({}, options), {}, {\n      signal: this.controller.signal\n    }));\n    this._connected();\n    var _iteratorAbruptCompletion2 = false;\n    var _didIteratorError2 = false;\n    var _iteratorError2;\n    try {\n      for (var _iterator2 = _asyncIterator(stream), _step2; _iteratorAbruptCompletion2 = !(_step2 = await _iterator2.next()).done; _iteratorAbruptCompletion2 = false) {\n        const event = _step2.value;\n        {\n          __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n          await _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n    if ((_stream$controller$si2 = stream.controller.signal) !== null && _stream$controller$si2 !== void 0 && _stream$controller$si2.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n  }\n  static createThreadAssistantStream(params, thread, options) {\n    const runner = new AssistantStream();\n    runner._run(() => runner._threadAssistantStream(params, thread, _objectSpread(_objectSpread({}, options), {}, {\n      headers: _objectSpread(_objectSpread({}, options === null || options === void 0 ? void 0 : options.headers), {}, {\n        'X-Stainless-Helper-Method': 'stream'\n      })\n    })));\n    return runner;\n  }\n  static createAssistantStream(threadId, runs, params, options) {\n    const runner = new AssistantStream();\n    runner._run(() => runner._runAssistantStream(threadId, runs, params, _objectSpread(_objectSpread({}, options), {}, {\n      headers: _objectSpread(_objectSpread({}, options === null || options === void 0 ? void 0 : options.headers), {}, {\n        'X-Stainless-Helper-Method': 'stream'\n      })\n    })));\n    return runner;\n  }\n  currentEvent() {\n    return __classPrivateFieldGet(this, _AssistantStream_currentEvent, \"f\");\n  }\n  currentRun() {\n    return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, \"f\");\n  }\n  currentMessageSnapshot() {\n    return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\");\n  }\n  currentRunStepSnapshot() {\n    return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, \"f\");\n  }\n  async finalRunSteps() {\n    await this.done();\n    return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\"));\n  }\n  async finalMessages() {\n    await this.done();\n    return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, \"f\"));\n  }\n  async finalRun() {\n    await this.done();\n    if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\")) throw Error('Final run was not received.');\n    return __classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\");\n  }\n  async _createThreadAssistantStream(thread, params, options) {\n    var _stream$controller$si3;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    const body = _objectSpread(_objectSpread({}, params), {}, {\n      stream: true\n    });\n    const stream = await thread.createAndRun(body, _objectSpread(_objectSpread({}, options), {}, {\n      signal: this.controller.signal\n    }));\n    this._connected();\n    var _iteratorAbruptCompletion3 = false;\n    var _didIteratorError3 = false;\n    var _iteratorError3;\n    try {\n      for (var _iterator3 = _asyncIterator(stream), _step3; _iteratorAbruptCompletion3 = !(_step3 = await _iterator3.next()).done; _iteratorAbruptCompletion3 = false) {\n        const event = _step3.value;\n        {\n          __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion3 && _iterator3.return != null) {\n          await _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n    if ((_stream$controller$si3 = stream.controller.signal) !== null && _stream$controller$si3 !== void 0 && _stream$controller$si3.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n  }\n  async _createAssistantStream(run, threadId, params, options) {\n    var _stream$controller$si4;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    const body = _objectSpread(_objectSpread({}, params), {}, {\n      stream: true\n    });\n    const stream = await run.create(threadId, body, _objectSpread(_objectSpread({}, options), {}, {\n      signal: this.controller.signal\n    }));\n    this._connected();\n    var _iteratorAbruptCompletion4 = false;\n    var _didIteratorError4 = false;\n    var _iteratorError4;\n    try {\n      for (var _iterator4 = _asyncIterator(stream), _step4; _iteratorAbruptCompletion4 = !(_step4 = await _iterator4.next()).done; _iteratorAbruptCompletion4 = false) {\n        const event = _step4.value;\n        {\n          __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion4 && _iterator4.return != null) {\n          await _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n    if ((_stream$controller$si4 = stream.controller.signal) !== null && _stream$controller$si4 !== void 0 && _stream$controller$si4.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n  }\n  static accumulateDelta(acc, delta) {\n    for (const [key, deltaValue] of Object.entries(delta)) {\n      if (!acc.hasOwnProperty(key)) {\n        acc[key] = deltaValue;\n        continue;\n      }\n      let accValue = acc[key];\n      if (accValue === null || accValue === undefined) {\n        acc[key] = deltaValue;\n        continue;\n      }\n      // We don't accumulate these special properties\n      if (key === 'index' || key === 'type') {\n        acc[key] = deltaValue;\n        continue;\n      }\n      // Type-specific accumulation logic\n      if (typeof accValue === 'string' && typeof deltaValue === 'string') {\n        accValue += deltaValue;\n      } else if (typeof accValue === 'number' && typeof deltaValue === 'number') {\n        accValue += deltaValue;\n      } else if (Core.isObj(accValue) && Core.isObj(deltaValue)) {\n        accValue = this.accumulateDelta(accValue, deltaValue);\n      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {\n        if (accValue.every(x => typeof x === 'string' || typeof x === 'number')) {\n          accValue.push(...deltaValue); // Use spread syntax for efficient addition\n          continue;\n        }\n        for (const deltaEntry of deltaValue) {\n          if (!Core.isObj(deltaEntry)) {\n            throw new Error(\"Expected array delta entry to be an object but got: \".concat(deltaEntry));\n          }\n          const index = deltaEntry['index'];\n          if (index == null) {\n            console.error(deltaEntry);\n            throw new Error('Expected array delta entry to have an `index` property');\n          }\n          if (typeof index !== 'number') {\n            throw new Error(\"Expected array delta entry `index` property to be a number but got \".concat(index));\n          }\n          const accEntry = accValue[index];\n          if (accEntry == null) {\n            accValue.push(deltaEntry);\n          } else {\n            accValue[index] = this.accumulateDelta(accEntry, deltaEntry);\n          }\n        }\n        continue;\n      } else {\n        throw Error(\"Unhandled record type: \".concat(key, \", deltaValue: \").concat(deltaValue, \", accValue: \").concat(accValue));\n      }\n      acc[key] = accValue;\n    }\n    return acc;\n  }\n  _addRun(run) {\n    return run;\n  }\n  async _threadAssistantStream(params, thread, options) {\n    return await this._createThreadAssistantStream(thread, params, options);\n  }\n  async _runAssistantStream(threadId, runs, params, options) {\n    return await this._createAssistantStream(runs, threadId, params, options);\n  }\n  async _runToolAssistantStream(threadId, runId, runs, params, options) {\n    return await this._createToolAssistantStream(runs, threadId, runId, params, options);\n  }\n}\n_AssistantStream_addEvent = function _AssistantStream_addEvent(event) {\n  if (this.ended) return;\n  __classPrivateFieldSet(this, _AssistantStream_currentEvent, event, \"f\");\n  __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleEvent).call(this, event);\n  switch (event.event) {\n    case 'thread.created':\n      //No action on this event.\n      break;\n    case 'thread.run.created':\n    case 'thread.run.queued':\n    case 'thread.run.in_progress':\n    case 'thread.run.requires_action':\n    case 'thread.run.completed':\n    case 'thread.run.incomplete':\n    case 'thread.run.failed':\n    case 'thread.run.cancelling':\n    case 'thread.run.cancelled':\n    case 'thread.run.expired':\n      __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleRun).call(this, event);\n      break;\n    case 'thread.run.step.created':\n    case 'thread.run.step.in_progress':\n    case 'thread.run.step.delta':\n    case 'thread.run.step.completed':\n    case 'thread.run.step.failed':\n    case 'thread.run.step.cancelled':\n    case 'thread.run.step.expired':\n      __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleRunStep).call(this, event);\n      break;\n    case 'thread.message.created':\n    case 'thread.message.in_progress':\n    case 'thread.message.delta':\n    case 'thread.message.completed':\n    case 'thread.message.incomplete':\n      __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleMessage).call(this, event);\n      break;\n    case 'error':\n      //This is included for completeness, but errors are processed in the SSE event processing so this should not occur\n      throw new Error('Encountered an error event in event processing - errors should be processed earlier');\n    default:\n      assertNever(event);\n  }\n}, _AssistantStream_endRequest = function _AssistantStream_endRequest() {\n  if (this.ended) {\n    throw new OpenAIError(\"stream has ended, this shouldn't happen\");\n  }\n  if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\")) throw Error('Final run has not been received');\n  return __classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\");\n}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage(event) {\n  const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n  __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, \"f\");\n  __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, \"f\")[accumulatedMessage.id] = accumulatedMessage;\n  for (const content of newContent) {\n    const snapshotContent = accumulatedMessage.content[content.index];\n    if ((snapshotContent === null || snapshotContent === void 0 ? void 0 : snapshotContent.type) == 'text') {\n      this._emit('textCreated', snapshotContent.text);\n    }\n  }\n  switch (event.event) {\n    case 'thread.message.created':\n      this._emit('messageCreated', event.data);\n      break;\n    case 'thread.message.in_progress':\n      break;\n    case 'thread.message.delta':\n      this._emit('messageDelta', event.data.delta, accumulatedMessage);\n      if (event.data.delta.content) {\n        for (const content of event.data.delta.content) {\n          //If it is text delta, emit a text delta event\n          if (content.type == 'text' && content.text) {\n            let textDelta = content.text;\n            let snapshot = accumulatedMessage.content[content.index];\n            if (snapshot && snapshot.type == 'text') {\n              this._emit('textDelta', textDelta, snapshot.text);\n            } else {\n              throw Error('The snapshot associated with this text delta is not text or missing');\n            }\n          }\n          if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\")) {\n            //See if we have in progress content\n            if (__classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\")) {\n              switch (__classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").type) {\n                case 'text':\n                  this._emit('textDone', __classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                  break;\n                case 'image_file':\n                  this._emit('imageFileDone', __classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                  break;\n              }\n            }\n            __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, \"f\");\n          }\n          __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], \"f\");\n        }\n      }\n      break;\n    case 'thread.message.completed':\n    case 'thread.message.incomplete':\n      //We emit the latest content we were working on on completion (including incomplete)\n      if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\") !== undefined) {\n        const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\")];\n        if (currentContent) {\n          switch (currentContent.type) {\n            case 'image_file':\n              this._emit('imageFileDone', currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n              break;\n            case 'text':\n              this._emit('textDone', currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n              break;\n          }\n        }\n      }\n      if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\")) {\n        this._emit('messageDone', event.data);\n      }\n      __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, undefined, \"f\");\n  }\n}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep(event) {\n  const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateRunStep).call(this, event);\n  __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, \"f\");\n  switch (event.event) {\n    case 'thread.run.step.created':\n      this._emit('runStepCreated', event.data);\n      break;\n    case 'thread.run.step.delta':\n      const delta = event.data.delta;\n      if (delta.step_details && delta.step_details.type == 'tool_calls' && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == 'tool_calls') {\n        for (const toolCall of delta.step_details.tool_calls) {\n          if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, \"f\")) {\n            this._emit('toolCallDelta', toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);\n          } else {\n            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n              this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n            }\n            __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, \"f\");\n            __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], \"f\");\n            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) this._emit('toolCallCreated', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n          }\n        }\n      }\n      this._emit('runStepDelta', event.data.delta, accumulatedRunStep);\n      break;\n    case 'thread.run.step.completed':\n    case 'thread.run.step.failed':\n    case 'thread.run.step.cancelled':\n    case 'thread.run.step.expired':\n      __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, undefined, \"f\");\n      const details = event.data.step_details;\n      if (details.type == 'tool_calls') {\n        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n          this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n          __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, \"f\");\n        }\n      }\n      this._emit('runStepDone', event.data, accumulatedRunStep);\n      break;\n    case 'thread.run.step.in_progress':\n      break;\n  }\n}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent(event) {\n  __classPrivateFieldGet(this, _AssistantStream_events, \"f\").push(event);\n  this._emit('event', event);\n}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep(event) {\n  switch (event.event) {\n    case 'thread.run.step.created':\n      __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = event.data;\n      return event.data;\n    case 'thread.run.step.delta':\n      let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n      if (!snapshot) {\n        throw Error('Received a RunStepDelta before creation of a snapshot');\n      }\n      let data = event.data;\n      if (data.delta) {\n        const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);\n        __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = accumulated;\n      }\n      return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n    case 'thread.run.step.completed':\n    case 'thread.run.step.failed':\n    case 'thread.run.step.cancelled':\n    case 'thread.run.step.expired':\n    case 'thread.run.step.in_progress':\n      __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = event.data;\n      break;\n  }\n  if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id]) return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n  throw new Error('No snapshot available');\n}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage(event, snapshot) {\n  let newContent = [];\n  switch (event.event) {\n    case 'thread.message.created':\n      //On creation the snapshot is just the initial message\n      return [event.data, newContent];\n    case 'thread.message.delta':\n      if (!snapshot) {\n        throw Error('Received a delta with no existing snapshot (there should be one from message creation)');\n      }\n      let data = event.data;\n      //If this delta does not have content, nothing to process\n      if (data.delta.content) {\n        for (const contentElement of data.delta.content) {\n          if (contentElement.index in snapshot.content) {\n            let currentContent = snapshot.content[contentElement.index];\n            snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);\n          } else {\n            snapshot.content[contentElement.index] = contentElement;\n            // This is a new element\n            newContent.push(contentElement);\n          }\n        }\n      }\n      return [snapshot, newContent];\n    case 'thread.message.in_progress':\n    case 'thread.message.completed':\n    case 'thread.message.incomplete':\n      //No changes on other thread events\n      if (snapshot) {\n        return [snapshot, newContent];\n      } else {\n        throw Error('Received thread message event with no existing snapshot');\n      }\n  }\n  throw Error('Tried to accumulate a non-message event');\n}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent(contentElement, currentContent) {\n  return AssistantStream.accumulateDelta(currentContent, contentElement);\n}, _AssistantStream_handleRun = function _AssistantStream_handleRun(event) {\n  __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, \"f\");\n  switch (event.event) {\n    case 'thread.run.created':\n      break;\n    case 'thread.run.queued':\n      break;\n    case 'thread.run.in_progress':\n      break;\n    case 'thread.run.requires_action':\n    case 'thread.run.cancelled':\n    case 'thread.run.failed':\n    case 'thread.run.completed':\n    case 'thread.run.expired':\n      __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, \"f\");\n      if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n        this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n        __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, \"f\");\n      }\n      break;\n    case 'thread.run.cancelling':\n      break;\n  }\n};\nfunction assertNever(_x) {}","map":{"version":3,"names":["Core","Stream","APIUserAbortError","OpenAIError","EventStream","AssistantStream","constructor","_AssistantStream_events","set","_AssistantStream_runStepSnapshots","_AssistantStream_messageSnapshots","_AssistantStream_messageSnapshot","_AssistantStream_finalRun","_AssistantStream_currentContentIndex","_AssistantStream_currentContent","_AssistantStream_currentToolCallIndex","_AssistantStream_currentToolCall","_AssistantStream_currentEvent","_AssistantStream_currentRunSnapshot","_AssistantStream_currentRunStepSnapshot","WeakMap","_AssistantStream_instances","WeakSet","Symbol","asyncIterator","pushQueue","readQueue","done","on","event","reader","shift","resolve","push","undefined","length","err","reject","next","value","Promise","then","chunk","return","abort","fromReadableStream","stream","runner","_run","_fromReadableStream","readableStream","options","_stream$controller$si","signal","aborted","controller","addEventListener","_connected","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","_step","__classPrivateFieldGet","_AssistantStream_addEvent","call","_addRun","_AssistantStream_endRequest","toReadableStream","bind","createToolAssistantStream","threadId","runId","runs","params","_runToolAssistantStream","_objectSpread","headers","_createToolAssistantStream","run","_stream$controller$si2","body","submitToolOutputs","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","createThreadAssistantStream","thread","_threadAssistantStream","createAssistantStream","_runAssistantStream","currentEvent","currentRun","currentMessageSnapshot","currentRunStepSnapshot","finalRunSteps","Object","values","finalMessages","finalRun","Error","_createThreadAssistantStream","_stream$controller$si3","createAndRun","_iteratorAbruptCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","_createAssistantStream","_stream$controller$si4","create","_iteratorAbruptCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","accumulateDelta","acc","delta","key","deltaValue","entries","hasOwnProperty","accValue","isObj","Array","isArray","every","x","deltaEntry","concat","index","console","error","accEntry","ended","__classPrivateFieldSet","_AssistantStream_handleEvent","_AssistantStream_handleRun","_AssistantStream_handleRunStep","_AssistantStream_handleMessage","assertNever","accumulatedMessage","newContent","_AssistantStream_accumulateMessage","id","content","snapshotContent","type","_emit","text","data","textDelta","snapshot","image_file","currentContent","accumulatedRunStep","_AssistantStream_accumulateRunStep","step_details","tool_calls","toolCall","details","accumulated","contentElement","_AssistantStream_accumulateContent","_x"],"sources":["C:\\co-1016\\node_modules\\openai\\src\\lib\\AssistantStream.ts"],"sourcesContent":["import {\r\n  TextContentBlock,\r\n  ImageFileContentBlock,\r\n  Message,\r\n  MessageContentDelta,\r\n  Text,\r\n  ImageFile,\r\n  TextDelta,\r\n  MessageDelta,\r\n  MessageContent,\r\n} from '../resources/beta/threads/messages';\r\nimport * as Core from '../core';\r\nimport { RequestOptions } from '../core';\r\nimport {\r\n  Run,\r\n  RunCreateParamsBase,\r\n  RunCreateParamsStreaming,\r\n  Runs,\r\n  RunSubmitToolOutputsParamsBase,\r\n  RunSubmitToolOutputsParamsStreaming,\r\n} from '../resources/beta/threads/runs/runs';\r\nimport { type ReadableStream } from '../_shims/index';\r\nimport { Stream } from '../streaming';\r\nimport { APIUserAbortError, OpenAIError } from '../error';\r\nimport {\r\n  AssistantStreamEvent,\r\n  MessageStreamEvent,\r\n  RunStepStreamEvent,\r\n  RunStreamEvent,\r\n} from '../resources/beta/assistants';\r\nimport { RunStep, RunStepDelta, ToolCall, ToolCallDelta } from '../resources/beta/threads/runs/steps';\r\nimport { ThreadCreateAndRunParamsBase, Threads } from '../resources/beta/threads/threads';\r\nimport { BaseEvents, EventStream } from './EventStream';\r\n\r\nexport interface AssistantStreamEvents extends BaseEvents {\r\n  run: (run: Run) => void;\r\n\r\n  //New event structure\r\n  messageCreated: (message: Message) => void;\r\n  messageDelta: (message: MessageDelta, snapshot: Message) => void;\r\n  messageDone: (message: Message) => void;\r\n\r\n  runStepCreated: (runStep: RunStep) => void;\r\n  runStepDelta: (delta: RunStepDelta, snapshot: Runs.RunStep) => void;\r\n  runStepDone: (runStep: Runs.RunStep, snapshot: Runs.RunStep) => void;\r\n\r\n  toolCallCreated: (toolCall: ToolCall) => void;\r\n  toolCallDelta: (delta: ToolCallDelta, snapshot: ToolCall) => void;\r\n  toolCallDone: (toolCall: ToolCall) => void;\r\n\r\n  textCreated: (content: Text) => void;\r\n  textDelta: (delta: TextDelta, snapshot: Text) => void;\r\n  textDone: (content: Text, snapshot: Message) => void;\r\n\r\n  //No created or delta as this is not streamed\r\n  imageFileDone: (content: ImageFile, snapshot: Message) => void;\r\n\r\n  event: (event: AssistantStreamEvent) => void;\r\n}\r\n\r\nexport type ThreadCreateAndRunParamsBaseStream = Omit<ThreadCreateAndRunParamsBase, 'stream'> & {\r\n  stream?: true;\r\n};\r\n\r\nexport type RunCreateParamsBaseStream = Omit<RunCreateParamsBase, 'stream'> & {\r\n  stream?: true;\r\n};\r\n\r\nexport type RunSubmitToolOutputsParamsStream = Omit<RunSubmitToolOutputsParamsBase, 'stream'> & {\r\n  stream?: true;\r\n};\r\n\r\nexport class AssistantStream\r\n  extends EventStream<AssistantStreamEvents>\r\n  implements AsyncIterable<AssistantStreamEvent>\r\n{\r\n  //Track all events in a single list for reference\r\n  #events: AssistantStreamEvent[] = [];\r\n\r\n  //Used to accumulate deltas\r\n  //We are accumulating many types so the value here is not strict\r\n  #runStepSnapshots: { [id: string]: Runs.RunStep } = {};\r\n  #messageSnapshots: { [id: string]: Message } = {};\r\n  #messageSnapshot: Message | undefined;\r\n  #finalRun: Run | undefined;\r\n  #currentContentIndex: number | undefined;\r\n  #currentContent: MessageContent | undefined;\r\n  #currentToolCallIndex: number | undefined;\r\n  #currentToolCall: ToolCall | undefined;\r\n\r\n  //For current snapshot methods\r\n  #currentEvent: AssistantStreamEvent | undefined;\r\n  #currentRunSnapshot: Run | undefined;\r\n  #currentRunStepSnapshot: Runs.RunStep | undefined;\r\n\r\n  [Symbol.asyncIterator](): AsyncIterator<AssistantStreamEvent> {\r\n    const pushQueue: AssistantStreamEvent[] = [];\r\n    const readQueue: {\r\n      resolve: (chunk: AssistantStreamEvent | undefined) => void;\r\n      reject: (err: unknown) => void;\r\n    }[] = [];\r\n    let done = false;\r\n\r\n    //Catch all for passing along all events\r\n    this.on('event', (event) => {\r\n      const reader = readQueue.shift();\r\n      if (reader) {\r\n        reader.resolve(event);\r\n      } else {\r\n        pushQueue.push(event);\r\n      }\r\n    });\r\n\r\n    this.on('end', () => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.resolve(undefined);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    this.on('abort', (err) => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.reject(err);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    this.on('error', (err) => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.reject(err);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    return {\r\n      next: async (): Promise<IteratorResult<AssistantStreamEvent>> => {\r\n        if (!pushQueue.length) {\r\n          if (done) {\r\n            return { value: undefined, done: true };\r\n          }\r\n          return new Promise<AssistantStreamEvent | undefined>((resolve, reject) =>\r\n            readQueue.push({ resolve, reject }),\r\n          ).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\r\n        }\r\n        const chunk = pushQueue.shift()!;\r\n        return { value: chunk, done: false };\r\n      },\r\n      return: async () => {\r\n        this.abort();\r\n        return { value: undefined, done: true };\r\n      },\r\n    };\r\n  }\r\n\r\n  static fromReadableStream(stream: ReadableStream): AssistantStream {\r\n    const runner = new AssistantStream();\r\n    runner._run(() => runner._fromReadableStream(stream));\r\n    return runner;\r\n  }\r\n\r\n  protected async _fromReadableStream(\r\n    readableStream: ReadableStream,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<Run> {\r\n    const signal = options?.signal;\r\n    if (signal) {\r\n      if (signal.aborted) this.controller.abort();\r\n      signal.addEventListener('abort', () => this.controller.abort());\r\n    }\r\n    this._connected();\r\n    const stream = Stream.fromReadableStream<AssistantStreamEvent>(readableStream, this.controller);\r\n    for await (const event of stream) {\r\n      this.#addEvent(event);\r\n    }\r\n    if (stream.controller.signal?.aborted) {\r\n      throw new APIUserAbortError();\r\n    }\r\n    return this._addRun(this.#endRequest());\r\n  }\r\n\r\n  toReadableStream(): ReadableStream {\r\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\r\n    return stream.toReadableStream();\r\n  }\r\n\r\n  static createToolAssistantStream(\r\n    threadId: string,\r\n    runId: string,\r\n    runs: Runs,\r\n    params: RunSubmitToolOutputsParamsStream,\r\n    options: RequestOptions | undefined,\r\n  ): AssistantStream {\r\n    const runner = new AssistantStream();\r\n    runner._run(() =>\r\n      runner._runToolAssistantStream(threadId, runId, runs, params, {\r\n        ...options,\r\n        headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\r\n      }),\r\n    );\r\n    return runner;\r\n  }\r\n\r\n  protected async _createToolAssistantStream(\r\n    run: Runs,\r\n    threadId: string,\r\n    runId: string,\r\n    params: RunSubmitToolOutputsParamsStream,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<Run> {\r\n    const signal = options?.signal;\r\n    if (signal) {\r\n      if (signal.aborted) this.controller.abort();\r\n      signal.addEventListener('abort', () => this.controller.abort());\r\n    }\r\n\r\n    const body: RunSubmitToolOutputsParamsStreaming = { ...params, stream: true };\r\n    const stream = await run.submitToolOutputs(threadId, runId, body, {\r\n      ...options,\r\n      signal: this.controller.signal,\r\n    });\r\n\r\n    this._connected();\r\n\r\n    for await (const event of stream) {\r\n      this.#addEvent(event);\r\n    }\r\n    if (stream.controller.signal?.aborted) {\r\n      throw new APIUserAbortError();\r\n    }\r\n\r\n    return this._addRun(this.#endRequest());\r\n  }\r\n\r\n  static createThreadAssistantStream(\r\n    params: ThreadCreateAndRunParamsBaseStream,\r\n    thread: Threads,\r\n    options?: RequestOptions,\r\n  ): AssistantStream {\r\n    const runner = new AssistantStream();\r\n    runner._run(() =>\r\n      runner._threadAssistantStream(params, thread, {\r\n        ...options,\r\n        headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\r\n      }),\r\n    );\r\n    return runner;\r\n  }\r\n\r\n  static createAssistantStream(\r\n    threadId: string,\r\n    runs: Runs,\r\n    params: RunCreateParamsBaseStream,\r\n    options?: RequestOptions,\r\n  ): AssistantStream {\r\n    const runner = new AssistantStream();\r\n    runner._run(() =>\r\n      runner._runAssistantStream(threadId, runs, params, {\r\n        ...options,\r\n        headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\r\n      }),\r\n    );\r\n    return runner;\r\n  }\r\n\r\n  currentEvent(): AssistantStreamEvent | undefined {\r\n    return this.#currentEvent;\r\n  }\r\n\r\n  currentRun(): Run | undefined {\r\n    return this.#currentRunSnapshot;\r\n  }\r\n\r\n  currentMessageSnapshot(): Message | undefined {\r\n    return this.#messageSnapshot;\r\n  }\r\n\r\n  currentRunStepSnapshot(): Runs.RunStep | undefined {\r\n    return this.#currentRunStepSnapshot;\r\n  }\r\n\r\n  async finalRunSteps(): Promise<Runs.RunStep[]> {\r\n    await this.done();\r\n\r\n    return Object.values(this.#runStepSnapshots);\r\n  }\r\n\r\n  async finalMessages(): Promise<Message[]> {\r\n    await this.done();\r\n\r\n    return Object.values(this.#messageSnapshots);\r\n  }\r\n\r\n  async finalRun(): Promise<Run> {\r\n    await this.done();\r\n    if (!this.#finalRun) throw Error('Final run was not received.');\r\n\r\n    return this.#finalRun;\r\n  }\r\n\r\n  protected async _createThreadAssistantStream(\r\n    thread: Threads,\r\n    params: ThreadCreateAndRunParamsBase,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<Run> {\r\n    const signal = options?.signal;\r\n    if (signal) {\r\n      if (signal.aborted) this.controller.abort();\r\n      signal.addEventListener('abort', () => this.controller.abort());\r\n    }\r\n\r\n    const body: RunCreateParamsStreaming = { ...params, stream: true };\r\n    const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });\r\n\r\n    this._connected();\r\n\r\n    for await (const event of stream) {\r\n      this.#addEvent(event);\r\n    }\r\n    if (stream.controller.signal?.aborted) {\r\n      throw new APIUserAbortError();\r\n    }\r\n\r\n    return this._addRun(this.#endRequest());\r\n  }\r\n\r\n  protected async _createAssistantStream(\r\n    run: Runs,\r\n    threadId: string,\r\n    params: RunCreateParamsBase,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<Run> {\r\n    const signal = options?.signal;\r\n    if (signal) {\r\n      if (signal.aborted) this.controller.abort();\r\n      signal.addEventListener('abort', () => this.controller.abort());\r\n    }\r\n\r\n    const body: RunCreateParamsStreaming = { ...params, stream: true };\r\n    const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });\r\n\r\n    this._connected();\r\n\r\n    for await (const event of stream) {\r\n      this.#addEvent(event);\r\n    }\r\n    if (stream.controller.signal?.aborted) {\r\n      throw new APIUserAbortError();\r\n    }\r\n\r\n    return this._addRun(this.#endRequest());\r\n  }\r\n\r\n  #addEvent(event: AssistantStreamEvent) {\r\n    if (this.ended) return;\r\n\r\n    this.#currentEvent = event;\r\n\r\n    this.#handleEvent(event);\r\n\r\n    switch (event.event) {\r\n      case 'thread.created':\r\n        //No action on this event.\r\n        break;\r\n\r\n      case 'thread.run.created':\r\n      case 'thread.run.queued':\r\n      case 'thread.run.in_progress':\r\n      case 'thread.run.requires_action':\r\n      case 'thread.run.completed':\r\n      case 'thread.run.incomplete':\r\n      case 'thread.run.failed':\r\n      case 'thread.run.cancelling':\r\n      case 'thread.run.cancelled':\r\n      case 'thread.run.expired':\r\n        this.#handleRun(event);\r\n        break;\r\n\r\n      case 'thread.run.step.created':\r\n      case 'thread.run.step.in_progress':\r\n      case 'thread.run.step.delta':\r\n      case 'thread.run.step.completed':\r\n      case 'thread.run.step.failed':\r\n      case 'thread.run.step.cancelled':\r\n      case 'thread.run.step.expired':\r\n        this.#handleRunStep(event);\r\n        break;\r\n\r\n      case 'thread.message.created':\r\n      case 'thread.message.in_progress':\r\n      case 'thread.message.delta':\r\n      case 'thread.message.completed':\r\n      case 'thread.message.incomplete':\r\n        this.#handleMessage(event);\r\n        break;\r\n\r\n      case 'error':\r\n        //This is included for completeness, but errors are processed in the SSE event processing so this should not occur\r\n        throw new Error(\r\n          'Encountered an error event in event processing - errors should be processed earlier',\r\n        );\r\n      default:\r\n        assertNever(event);\r\n    }\r\n  }\r\n\r\n  #endRequest(): Run {\r\n    if (this.ended) {\r\n      throw new OpenAIError(`stream has ended, this shouldn't happen`);\r\n    }\r\n\r\n    if (!this.#finalRun) throw Error('Final run has not been received');\r\n\r\n    return this.#finalRun;\r\n  }\r\n\r\n  #handleMessage(this: AssistantStream, event: MessageStreamEvent) {\r\n    const [accumulatedMessage, newContent] = this.#accumulateMessage(event, this.#messageSnapshot);\r\n    this.#messageSnapshot = accumulatedMessage;\r\n    this.#messageSnapshots[accumulatedMessage.id] = accumulatedMessage;\r\n\r\n    for (const content of newContent) {\r\n      const snapshotContent = accumulatedMessage.content[content.index];\r\n      if (snapshotContent?.type == 'text') {\r\n        this._emit('textCreated', snapshotContent.text);\r\n      }\r\n    }\r\n\r\n    switch (event.event) {\r\n      case 'thread.message.created':\r\n        this._emit('messageCreated', event.data);\r\n        break;\r\n\r\n      case 'thread.message.in_progress':\r\n        break;\r\n\r\n      case 'thread.message.delta':\r\n        this._emit('messageDelta', event.data.delta, accumulatedMessage);\r\n\r\n        if (event.data.delta.content) {\r\n          for (const content of event.data.delta.content) {\r\n            //If it is text delta, emit a text delta event\r\n            if (content.type == 'text' && content.text) {\r\n              let textDelta = content.text;\r\n              let snapshot = accumulatedMessage.content[content.index];\r\n              if (snapshot && snapshot.type == 'text') {\r\n                this._emit('textDelta', textDelta, snapshot.text);\r\n              } else {\r\n                throw Error('The snapshot associated with this text delta is not text or missing');\r\n              }\r\n            }\r\n\r\n            if (content.index != this.#currentContentIndex) {\r\n              //See if we have in progress content\r\n              if (this.#currentContent) {\r\n                switch (this.#currentContent.type) {\r\n                  case 'text':\r\n                    this._emit('textDone', this.#currentContent.text, this.#messageSnapshot);\r\n                    break;\r\n                  case 'image_file':\r\n                    this._emit('imageFileDone', this.#currentContent.image_file, this.#messageSnapshot);\r\n                    break;\r\n                }\r\n              }\r\n\r\n              this.#currentContentIndex = content.index;\r\n            }\r\n\r\n            this.#currentContent = accumulatedMessage.content[content.index];\r\n          }\r\n        }\r\n\r\n        break;\r\n\r\n      case 'thread.message.completed':\r\n      case 'thread.message.incomplete':\r\n        //We emit the latest content we were working on on completion (including incomplete)\r\n        if (this.#currentContentIndex !== undefined) {\r\n          const currentContent = event.data.content[this.#currentContentIndex];\r\n          if (currentContent) {\r\n            switch (currentContent.type) {\r\n              case 'image_file':\r\n                this._emit('imageFileDone', currentContent.image_file, this.#messageSnapshot);\r\n                break;\r\n              case 'text':\r\n                this._emit('textDone', currentContent.text, this.#messageSnapshot);\r\n                break;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (this.#messageSnapshot) {\r\n          this._emit('messageDone', event.data);\r\n        }\r\n\r\n        this.#messageSnapshot = undefined;\r\n    }\r\n  }\r\n\r\n  #handleRunStep(this: AssistantStream, event: RunStepStreamEvent) {\r\n    const accumulatedRunStep = this.#accumulateRunStep(event);\r\n    this.#currentRunStepSnapshot = accumulatedRunStep;\r\n\r\n    switch (event.event) {\r\n      case 'thread.run.step.created':\r\n        this._emit('runStepCreated', event.data);\r\n        break;\r\n      case 'thread.run.step.delta':\r\n        const delta = event.data.delta;\r\n        if (\r\n          delta.step_details &&\r\n          delta.step_details.type == 'tool_calls' &&\r\n          delta.step_details.tool_calls &&\r\n          accumulatedRunStep.step_details.type == 'tool_calls'\r\n        ) {\r\n          for (const toolCall of delta.step_details.tool_calls) {\r\n            if (toolCall.index == this.#currentToolCallIndex) {\r\n              this._emit(\r\n                'toolCallDelta',\r\n                toolCall,\r\n                accumulatedRunStep.step_details.tool_calls[toolCall.index] as ToolCall,\r\n              );\r\n            } else {\r\n              if (this.#currentToolCall) {\r\n                this._emit('toolCallDone', this.#currentToolCall);\r\n              }\r\n\r\n              this.#currentToolCallIndex = toolCall.index;\r\n              this.#currentToolCall = accumulatedRunStep.step_details.tool_calls[toolCall.index];\r\n              if (this.#currentToolCall) this._emit('toolCallCreated', this.#currentToolCall);\r\n            }\r\n          }\r\n        }\r\n\r\n        this._emit('runStepDelta', event.data.delta, accumulatedRunStep);\r\n        break;\r\n      case 'thread.run.step.completed':\r\n      case 'thread.run.step.failed':\r\n      case 'thread.run.step.cancelled':\r\n      case 'thread.run.step.expired':\r\n        this.#currentRunStepSnapshot = undefined;\r\n        const details = event.data.step_details;\r\n        if (details.type == 'tool_calls') {\r\n          if (this.#currentToolCall) {\r\n            this._emit('toolCallDone', this.#currentToolCall as ToolCall);\r\n            this.#currentToolCall = undefined;\r\n          }\r\n        }\r\n        this._emit('runStepDone', event.data, accumulatedRunStep);\r\n        break;\r\n      case 'thread.run.step.in_progress':\r\n        break;\r\n    }\r\n  }\r\n\r\n  #handleEvent(this: AssistantStream, event: AssistantStreamEvent) {\r\n    this.#events.push(event);\r\n    this._emit('event', event);\r\n  }\r\n\r\n  #accumulateRunStep(event: RunStepStreamEvent): Runs.RunStep {\r\n    switch (event.event) {\r\n      case 'thread.run.step.created':\r\n        this.#runStepSnapshots[event.data.id] = event.data;\r\n        return event.data;\r\n\r\n      case 'thread.run.step.delta':\r\n        let snapshot = this.#runStepSnapshots[event.data.id] as Runs.RunStep;\r\n        if (!snapshot) {\r\n          throw Error('Received a RunStepDelta before creation of a snapshot');\r\n        }\r\n\r\n        let data = event.data;\r\n\r\n        if (data.delta) {\r\n          const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta) as Runs.RunStep;\r\n          this.#runStepSnapshots[event.data.id] = accumulated;\r\n        }\r\n\r\n        return this.#runStepSnapshots[event.data.id] as Runs.RunStep;\r\n\r\n      case 'thread.run.step.completed':\r\n      case 'thread.run.step.failed':\r\n      case 'thread.run.step.cancelled':\r\n      case 'thread.run.step.expired':\r\n      case 'thread.run.step.in_progress':\r\n        this.#runStepSnapshots[event.data.id] = event.data;\r\n        break;\r\n    }\r\n\r\n    if (this.#runStepSnapshots[event.data.id]) return this.#runStepSnapshots[event.data.id] as Runs.RunStep;\r\n    throw new Error('No snapshot available');\r\n  }\r\n\r\n  #accumulateMessage(\r\n    event: AssistantStreamEvent,\r\n    snapshot: Message | undefined,\r\n  ): [Message, MessageContentDelta[]] {\r\n    let newContent: MessageContentDelta[] = [];\r\n\r\n    switch (event.event) {\r\n      case 'thread.message.created':\r\n        //On creation the snapshot is just the initial message\r\n        return [event.data, newContent];\r\n\r\n      case 'thread.message.delta':\r\n        if (!snapshot) {\r\n          throw Error(\r\n            'Received a delta with no existing snapshot (there should be one from message creation)',\r\n          );\r\n        }\r\n\r\n        let data = event.data;\r\n\r\n        //If this delta does not have content, nothing to process\r\n        if (data.delta.content) {\r\n          for (const contentElement of data.delta.content) {\r\n            if (contentElement.index in snapshot.content) {\r\n              let currentContent = snapshot.content[contentElement.index];\r\n              snapshot.content[contentElement.index] = this.#accumulateContent(\r\n                contentElement,\r\n                currentContent,\r\n              );\r\n            } else {\r\n              snapshot.content[contentElement.index] = contentElement as MessageContent;\r\n              // This is a new element\r\n              newContent.push(contentElement);\r\n            }\r\n          }\r\n        }\r\n\r\n        return [snapshot, newContent];\r\n\r\n      case 'thread.message.in_progress':\r\n      case 'thread.message.completed':\r\n      case 'thread.message.incomplete':\r\n        //No changes on other thread events\r\n        if (snapshot) {\r\n          return [snapshot, newContent];\r\n        } else {\r\n          throw Error('Received thread message event with no existing snapshot');\r\n        }\r\n    }\r\n    throw Error('Tried to accumulate a non-message event');\r\n  }\r\n\r\n  #accumulateContent(\r\n    contentElement: MessageContentDelta,\r\n    currentContent: MessageContent | undefined,\r\n  ): TextContentBlock | ImageFileContentBlock {\r\n    return AssistantStream.accumulateDelta(currentContent as unknown as Record<any, any>, contentElement) as\r\n      | TextContentBlock\r\n      | ImageFileContentBlock;\r\n  }\r\n\r\n  static accumulateDelta(acc: Record<string, any>, delta: Record<string, any>): Record<string, any> {\r\n    for (const [key, deltaValue] of Object.entries(delta)) {\r\n      if (!acc.hasOwnProperty(key)) {\r\n        acc[key] = deltaValue;\r\n        continue;\r\n      }\r\n\r\n      let accValue = acc[key];\r\n      if (accValue === null || accValue === undefined) {\r\n        acc[key] = deltaValue;\r\n        continue;\r\n      }\r\n\r\n      // We don't accumulate these special properties\r\n      if (key === 'index' || key === 'type') {\r\n        acc[key] = deltaValue;\r\n        continue;\r\n      }\r\n\r\n      // Type-specific accumulation logic\r\n      if (typeof accValue === 'string' && typeof deltaValue === 'string') {\r\n        accValue += deltaValue;\r\n      } else if (typeof accValue === 'number' && typeof deltaValue === 'number') {\r\n        accValue += deltaValue;\r\n      } else if (Core.isObj(accValue) && Core.isObj(deltaValue)) {\r\n        accValue = this.accumulateDelta(accValue as Record<string, any>, deltaValue as Record<string, any>);\r\n      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {\r\n        if (accValue.every((x) => typeof x === 'string' || typeof x === 'number')) {\r\n          accValue.push(...deltaValue); // Use spread syntax for efficient addition\r\n          continue;\r\n        }\r\n\r\n        for (const deltaEntry of deltaValue) {\r\n          if (!Core.isObj(deltaEntry)) {\r\n            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);\r\n          }\r\n\r\n          const index = deltaEntry['index'];\r\n          if (index == null) {\r\n            console.error(deltaEntry);\r\n            throw new Error('Expected array delta entry to have an `index` property');\r\n          }\r\n\r\n          if (typeof index !== 'number') {\r\n            throw new Error(`Expected array delta entry \\`index\\` property to be a number but got ${index}`);\r\n          }\r\n\r\n          const accEntry = accValue[index];\r\n          if (accEntry == null) {\r\n            accValue.push(deltaEntry);\r\n          } else {\r\n            accValue[index] = this.accumulateDelta(accEntry, deltaEntry);\r\n          }\r\n        }\r\n        continue;\r\n      } else {\r\n        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);\r\n      }\r\n      acc[key] = accValue;\r\n    }\r\n\r\n    return acc;\r\n  }\r\n\r\n  #handleRun(this: AssistantStream, event: RunStreamEvent) {\r\n    this.#currentRunSnapshot = event.data;\r\n    switch (event.event) {\r\n      case 'thread.run.created':\r\n        break;\r\n      case 'thread.run.queued':\r\n        break;\r\n      case 'thread.run.in_progress':\r\n        break;\r\n      case 'thread.run.requires_action':\r\n      case 'thread.run.cancelled':\r\n      case 'thread.run.failed':\r\n      case 'thread.run.completed':\r\n      case 'thread.run.expired':\r\n        this.#finalRun = event.data;\r\n        if (this.#currentToolCall) {\r\n          this._emit('toolCallDone', this.#currentToolCall);\r\n          this.#currentToolCall = undefined;\r\n        }\r\n        break;\r\n      case 'thread.run.cancelling':\r\n        break;\r\n    }\r\n  }\r\n\r\n  protected _addRun(run: Run): Run {\r\n    return run;\r\n  }\r\n\r\n  protected async _threadAssistantStream(\r\n    params: ThreadCreateAndRunParamsBase,\r\n    thread: Threads,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<Run> {\r\n    return await this._createThreadAssistantStream(thread, params, options);\r\n  }\r\n\r\n  protected async _runAssistantStream(\r\n    threadId: string,\r\n    runs: Runs,\r\n    params: RunCreateParamsBase,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<Run> {\r\n    return await this._createAssistantStream(runs, threadId, params, options);\r\n  }\r\n\r\n  protected async _runToolAssistantStream(\r\n    threadId: string,\r\n    runId: string,\r\n    runs: Runs,\r\n    params: RunSubmitToolOutputsParamsStream,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<Run> {\r\n    return await this._createToolAssistantStream(runs, threadId, runId, params, options);\r\n  }\r\n}\r\n\r\nfunction assertNever(_x: never) {}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}