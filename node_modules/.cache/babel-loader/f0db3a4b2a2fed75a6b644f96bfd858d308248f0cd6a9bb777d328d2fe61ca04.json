{"ast":null,"code":"var _s = $RefreshSig$();\n/**\r\n * CuratorOdyssey Phase 2 - Advanced Chart Synchronization System\r\n * Dr. Sarah Kim's Dual-Chart State Management Hook\r\n * \r\n * EventTimeline ↔ StackedAreaChart 완벽 동기화\r\n */\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\nexport const useChartSynchronization = (timeseriesData, events = []) => {\n  _s();\n  // 통합 상태 관리\n  const [synchronizedState, setSynchronizedState] = useState({\n    // 시간 관련 상태\n    timeRange: [0, 20],\n    hoveredTime: null,\n    selectedTimeRange: null,\n    // 이벤트 관련 상태  \n    hoveredEvent: null,\n    selectedEvent: null,\n    // 줌/팬 상태\n    zoomLevel: 1,\n    panOffset: 0,\n    // 차트별 상태\n    chartStates: {\n      stackedArea: {\n        isReady: false,\n        lastUpdate: null,\n        renderTime: null\n      },\n      eventTimeline: {\n        isReady: false,\n        lastUpdate: null,\n        renderTime: null\n      }\n    }\n  });\n\n  // 성능 추적을 위한 ref\n  const performanceRef = useRef({\n    lastSyncTime: Date.now(),\n    syncOperations: 0,\n    averageSyncTime: 0\n  });\n\n  // 디바운스를 위한 ref\n  const debounceRef = useRef({\n    timeHover: null,\n    eventHover: null,\n    zoomPan: null\n  });\n\n  // 1. 시간 호버 동기화 (디바운스 적용)\n  const handleTimeHover = useCallback(timeData => {\n    if (debounceRef.current.timeHover) {\n      clearTimeout(debounceRef.current.timeHover);\n    }\n    debounceRef.current.timeHover = setTimeout(() => {\n      const startTime = performance.now();\n      setSynchronizedState(prev => {\n        const newState = {\n          ...prev,\n          hoveredTime: (timeData === null || timeData === void 0 ? void 0 : timeData.t) || null,\n          hoveredEvent: null // 시간 호버 시 이벤트 호버 해제\n        };\n\n        // 성능 추적\n        const syncTime = performance.now() - startTime;\n        performanceRef.current.lastSyncTime = syncTime;\n        performanceRef.current.syncOperations++;\n        performanceRef.current.averageSyncTime = (performanceRef.current.averageSyncTime * (performanceRef.current.syncOperations - 1) + syncTime) / performanceRef.current.syncOperations;\n        return newState;\n      });\n    }, 16); // 60fps 기준\n  }, []);\n\n  // 2. 이벤트 호버 동기화\n  const handleEventHover = useCallback(eventId => {\n    if (debounceRef.current.eventHover) {\n      clearTimeout(debounceRef.current.eventHover);\n    }\n    debounceRef.current.eventHover = setTimeout(() => {\n      setSynchronizedState(prev => {\n        const hoveredEvent = eventId ? events.find(e => e.id === eventId) : null;\n        return {\n          ...prev,\n          hoveredEvent: eventId,\n          hoveredTime: hoveredEvent ? hoveredEvent.t : prev.hoveredTime\n        };\n      });\n    }, 8); // 이벤트 호버는 더 빠른 응답\n  }, [events]);\n\n  // 3. 시간 범위 변경 (줌/팬) 동기화\n  const handleTimeRangeChange = useCallback((newRange, source = 'manual') => {\n    if (debounceRef.current.zoomPan) {\n      clearTimeout(debounceRef.current.zoomPan);\n    }\n    debounceRef.current.zoomPan = setTimeout(() => {\n      setSynchronizedState(prev => {\n        const [start, end] = newRange;\n        const duration = end - start;\n        const center = (start + end) / 2;\n\n        // 유효성 검사\n        if (start < 0 || end > 25 || start >= end) {\n          console.warn('Invalid time range:', newRange);\n          return prev;\n        }\n        return {\n          ...prev,\n          timeRange: [start, end],\n          zoomLevel: 20 / duration,\n          // 기본 20년 대비 줌 레벨\n          panOffset: center - 10,\n          // 기본 중심점(10년) 대비 오프셋\n          selectedTimeRange: source === 'selection' ? newRange : null\n        };\n      });\n    }, 32); // 줌/팬은 적당한 디바운스\n  }, []);\n\n  // 4. 이벤트 선택 동기화\n  const handleEventSelect = useCallback(event => {\n    setSynchronizedState(prev => ({\n      ...prev,\n      selectedEvent: event,\n      hoveredTime: event ? event.t : null,\n      // 선택된 이벤트 주변으로 시간 범위 조정\n      timeRange: event ? [Math.max(0, event.t - 3), Math.min(20, event.t + 3)] : prev.timeRange\n    }));\n  }, []);\n\n  // 5. 차트 상태 업데이트 (렌더링 완료 시점 추적)\n  const updateChartState = useCallback((chartType, stateUpdate) => {\n    setSynchronizedState(prev => ({\n      ...prev,\n      chartStates: {\n        ...prev.chartStates,\n        [chartType]: {\n          ...prev.chartStates[chartType],\n          ...stateUpdate,\n          lastUpdate: Date.now()\n        }\n      }\n    }));\n  }, []);\n\n  // 6. 양방향 동기화 감지 및 처리\n  useEffect(() => {\n    // 두 차트가 모두 준비되었을 때 초기 동기화\n    const {\n      stackedArea,\n      eventTimeline\n    } = synchronizedState.chartStates;\n    if (stackedArea.isReady && eventTimeline.isReady) {\n      var _timeseriesData$bins;\n      // 초기 시간 범위 설정\n      if ((timeseriesData === null || timeseriesData === void 0 ? void 0 : (_timeseriesData$bins = timeseriesData.bins) === null || _timeseriesData$bins === void 0 ? void 0 : _timeseriesData$bins.length) > 0) {\n        const minTime = Math.min(...timeseriesData.bins.map(d => d.t));\n        const maxTime = Math.max(...timeseriesData.bins.map(d => d.t));\n        setSynchronizedState(prev => ({\n          ...prev,\n          timeRange: [minTime, maxTime]\n        }));\n      }\n    }\n  }, [synchronizedState.chartStates, timeseriesData]);\n\n  // 7. 성능 모니터링\n  const getPerformanceStats = useCallback(() => {\n    return {\n      lastSyncTime: performanceRef.current.lastSyncTime,\n      totalSyncOperations: performanceRef.current.syncOperations,\n      averageSyncTime: performanceRef.current.averageSyncTime,\n      isOptimal: performanceRef.current.averageSyncTime < 16 // 60fps 기준\n    };\n  }, []);\n\n  // 8. 줌 인/아웃 헬퍼 함수들\n  const zoomIn = useCallback((factor = 0.5) => {\n    const [start, end] = synchronizedState.timeRange;\n    const center = (start + end) / 2;\n    const newDuration = (end - start) * factor;\n    handleTimeRangeChange([center - newDuration / 2, center + newDuration / 2], 'zoom');\n  }, [synchronizedState.timeRange, handleTimeRangeChange]);\n  const zoomOut = useCallback((factor = 2) => {\n    const [start, end] = synchronizedState.timeRange;\n    const center = (start + end) / 2;\n    const newDuration = (end - start) * factor;\n    handleTimeRangeChange([Math.max(0, center - newDuration / 2), Math.min(20, center + newDuration / 2)], 'zoom');\n  }, [synchronizedState.timeRange, handleTimeRangeChange]);\n  const panLeft = useCallback((amount = 2) => {\n    const [start, end] = synchronizedState.timeRange;\n    const duration = end - start;\n    handleTimeRangeChange([Math.max(0, start - amount), Math.max(duration, end - amount)], 'pan');\n  }, [synchronizedState.timeRange, handleTimeRangeChange]);\n  const panRight = useCallback((amount = 2) => {\n    const [start, end] = synchronizedState.timeRange;\n    const duration = end - start;\n    handleTimeRangeChange([Math.min(20 - duration, start + amount), Math.min(20, end + amount)], 'pan');\n  }, [synchronizedState.timeRange, handleTimeRangeChange]);\n\n  // 9. 리셋 함수\n  const resetView = useCallback(() => {\n    setSynchronizedState(prev => ({\n      ...prev,\n      timeRange: [0, 20],\n      hoveredTime: null,\n      hoveredEvent: null,\n      selectedEvent: null,\n      selectedTimeRange: null,\n      zoomLevel: 1,\n      panOffset: 0\n    }));\n  }, []);\n\n  // 10. 이벤트 필터링 (현재 시간 범위 기준)\n  const getVisibleEvents = useCallback(() => {\n    const [start, end] = synchronizedState.timeRange;\n    return events.filter(event => event.t >= start && event.t <= end);\n  }, [events, synchronizedState.timeRange]);\n\n  // Clean up\n  useEffect(() => {\n    return () => {\n      Object.values(debounceRef.current).forEach(timeout => {\n        if (timeout) clearTimeout(timeout);\n      });\n    };\n  }, []);\n  return {\n    // 상태\n    synchronizedState,\n    // 이벤트 핸들러\n    onTimeHover: handleTimeHover,\n    onEventHover: handleEventHover,\n    onTimeRangeChange: handleTimeRangeChange,\n    onEventSelect: handleEventSelect,\n    updateChartState,\n    // 줌/팬 컨트롤\n    zoomIn,\n    zoomOut,\n    panLeft,\n    panRight,\n    resetView,\n    // 유틸리티\n    getVisibleEvents,\n    getPerformanceStats,\n    // 개별 상태 접근자 (편의성)\n    timeRange: synchronizedState.timeRange,\n    hoveredTime: synchronizedState.hoveredTime,\n    hoveredEvent: synchronizedState.hoveredEvent,\n    selectedEvent: synchronizedState.selectedEvent,\n    zoomLevel: synchronizedState.zoomLevel\n  };\n};\n_s(useChartSynchronization, \"2pdR3f/bhqKUkDaoBysqHP4YlB0=\");\nexport default useChartSynchronization;","map":{"version":3,"names":["useState","useCallback","useRef","useEffect","useChartSynchronization","timeseriesData","events","_s","synchronizedState","setSynchronizedState","timeRange","hoveredTime","selectedTimeRange","hoveredEvent","selectedEvent","zoomLevel","panOffset","chartStates","stackedArea","isReady","lastUpdate","renderTime","eventTimeline","performanceRef","lastSyncTime","Date","now","syncOperations","averageSyncTime","debounceRef","timeHover","eventHover","zoomPan","handleTimeHover","timeData","current","clearTimeout","setTimeout","startTime","performance","prev","newState","t","syncTime","handleEventHover","eventId","find","e","id","handleTimeRangeChange","newRange","source","start","end","duration","center","console","warn","handleEventSelect","event","Math","max","min","updateChartState","chartType","stateUpdate","_timeseriesData$bins","bins","length","minTime","map","d","maxTime","getPerformanceStats","totalSyncOperations","isOptimal","zoomIn","factor","newDuration","zoomOut","panLeft","amount","panRight","resetView","getVisibleEvents","filter","Object","values","forEach","timeout","onTimeHover","onEventHover","onTimeRangeChange","onEventSelect"],"sources":["C:/CuratorOdyssey/src/hooks/useChartSynchronization.js"],"sourcesContent":["/**\r\n * CuratorOdyssey Phase 2 - Advanced Chart Synchronization System\r\n * Dr. Sarah Kim's Dual-Chart State Management Hook\r\n * \r\n * EventTimeline ↔ StackedAreaChart 완벽 동기화\r\n */\r\n\r\nimport { useState, useCallback, useRef, useEffect } from 'react';\r\n\r\nexport const useChartSynchronization = (timeseriesData, events = []) => {\r\n  // 통합 상태 관리\r\n  const [synchronizedState, setSynchronizedState] = useState({\r\n    // 시간 관련 상태\r\n    timeRange: [0, 20],\r\n    hoveredTime: null,\r\n    selectedTimeRange: null,\r\n    \r\n    // 이벤트 관련 상태  \r\n    hoveredEvent: null,\r\n    selectedEvent: null,\r\n    \r\n    // 줌/팬 상태\r\n    zoomLevel: 1,\r\n    panOffset: 0,\r\n    \r\n    // 차트별 상태\r\n    chartStates: {\r\n      stackedArea: {\r\n        isReady: false,\r\n        lastUpdate: null,\r\n        renderTime: null\r\n      },\r\n      eventTimeline: {\r\n        isReady: false,\r\n        lastUpdate: null,\r\n        renderTime: null\r\n      }\r\n    }\r\n  });\r\n\r\n  // 성능 추적을 위한 ref\r\n  const performanceRef = useRef({\r\n    lastSyncTime: Date.now(),\r\n    syncOperations: 0,\r\n    averageSyncTime: 0\r\n  });\r\n\r\n  // 디바운스를 위한 ref\r\n  const debounceRef = useRef({\r\n    timeHover: null,\r\n    eventHover: null,\r\n    zoomPan: null\r\n  });\r\n\r\n  // 1. 시간 호버 동기화 (디바운스 적용)\r\n  const handleTimeHover = useCallback((timeData) => {\r\n    if (debounceRef.current.timeHover) {\r\n      clearTimeout(debounceRef.current.timeHover);\r\n    }\r\n    \r\n    debounceRef.current.timeHover = setTimeout(() => {\r\n      const startTime = performance.now();\r\n      \r\n      setSynchronizedState(prev => {\r\n        const newState = {\r\n          ...prev,\r\n          hoveredTime: timeData?.t || null,\r\n          hoveredEvent: null // 시간 호버 시 이벤트 호버 해제\r\n        };\r\n        \r\n        // 성능 추적\r\n        const syncTime = performance.now() - startTime;\r\n        performanceRef.current.lastSyncTime = syncTime;\r\n        performanceRef.current.syncOperations++;\r\n        performanceRef.current.averageSyncTime = \r\n          (performanceRef.current.averageSyncTime * (performanceRef.current.syncOperations - 1) + syncTime) \r\n          / performanceRef.current.syncOperations;\r\n        \r\n        return newState;\r\n      });\r\n    }, 16); // 60fps 기준\r\n  }, []);\r\n\r\n  // 2. 이벤트 호버 동기화\r\n  const handleEventHover = useCallback((eventId) => {\r\n    if (debounceRef.current.eventHover) {\r\n      clearTimeout(debounceRef.current.eventHover);\r\n    }\r\n    \r\n    debounceRef.current.eventHover = setTimeout(() => {\r\n      setSynchronizedState(prev => {\r\n        const hoveredEvent = eventId ? events.find(e => e.id === eventId) : null;\r\n        \r\n        return {\r\n          ...prev,\r\n          hoveredEvent: eventId,\r\n          hoveredTime: hoveredEvent ? hoveredEvent.t : prev.hoveredTime\r\n        };\r\n      });\r\n    }, 8); // 이벤트 호버는 더 빠른 응답\r\n  }, [events]);\r\n\r\n  // 3. 시간 범위 변경 (줌/팬) 동기화\r\n  const handleTimeRangeChange = useCallback((newRange, source = 'manual') => {\r\n    if (debounceRef.current.zoomPan) {\r\n      clearTimeout(debounceRef.current.zoomPan);\r\n    }\r\n    \r\n    debounceRef.current.zoomPan = setTimeout(() => {\r\n      setSynchronizedState(prev => {\r\n        const [start, end] = newRange;\r\n        const duration = end - start;\r\n        const center = (start + end) / 2;\r\n        \r\n        // 유효성 검사\r\n        if (start < 0 || end > 25 || start >= end) {\r\n          console.warn('Invalid time range:', newRange);\r\n          return prev;\r\n        }\r\n        \r\n        return {\r\n          ...prev,\r\n          timeRange: [start, end],\r\n          zoomLevel: 20 / duration, // 기본 20년 대비 줌 레벨\r\n          panOffset: center - 10, // 기본 중심점(10년) 대비 오프셋\r\n          selectedTimeRange: source === 'selection' ? newRange : null\r\n        };\r\n      });\r\n    }, 32); // 줌/팬은 적당한 디바운스\r\n  }, []);\r\n\r\n  // 4. 이벤트 선택 동기화\r\n  const handleEventSelect = useCallback((event) => {\r\n    setSynchronizedState(prev => ({\r\n      ...prev,\r\n      selectedEvent: event,\r\n      hoveredTime: event ? event.t : null,\r\n      // 선택된 이벤트 주변으로 시간 범위 조정\r\n      timeRange: event ? [\r\n        Math.max(0, event.t - 3),\r\n        Math.min(20, event.t + 3)\r\n      ] : prev.timeRange\r\n    }));\r\n  }, []);\r\n\r\n  // 5. 차트 상태 업데이트 (렌더링 완료 시점 추적)\r\n  const updateChartState = useCallback((chartType, stateUpdate) => {\r\n    setSynchronizedState(prev => ({\r\n      ...prev,\r\n      chartStates: {\r\n        ...prev.chartStates,\r\n        [chartType]: {\r\n          ...prev.chartStates[chartType],\r\n          ...stateUpdate,\r\n          lastUpdate: Date.now()\r\n        }\r\n      }\r\n    }));\r\n  }, []);\r\n\r\n  // 6. 양방향 동기화 감지 및 처리\r\n  useEffect(() => {\r\n    // 두 차트가 모두 준비되었을 때 초기 동기화\r\n    const { stackedArea, eventTimeline } = synchronizedState.chartStates;\r\n    \r\n    if (stackedArea.isReady && eventTimeline.isReady) {\r\n      // 초기 시간 범위 설정\r\n      if (timeseriesData?.bins?.length > 0) {\r\n        const minTime = Math.min(...timeseriesData.bins.map(d => d.t));\r\n        const maxTime = Math.max(...timeseriesData.bins.map(d => d.t));\r\n        \r\n        setSynchronizedState(prev => ({\r\n          ...prev,\r\n          timeRange: [minTime, maxTime]\r\n        }));\r\n      }\r\n    }\r\n  }, [synchronizedState.chartStates, timeseriesData]);\r\n\r\n  // 7. 성능 모니터링\r\n  const getPerformanceStats = useCallback(() => {\r\n    return {\r\n      lastSyncTime: performanceRef.current.lastSyncTime,\r\n      totalSyncOperations: performanceRef.current.syncOperations,\r\n      averageSyncTime: performanceRef.current.averageSyncTime,\r\n      isOptimal: performanceRef.current.averageSyncTime < 16 // 60fps 기준\r\n    };\r\n  }, []);\r\n\r\n  // 8. 줌 인/아웃 헬퍼 함수들\r\n  const zoomIn = useCallback((factor = 0.5) => {\r\n    const [start, end] = synchronizedState.timeRange;\r\n    const center = (start + end) / 2;\r\n    const newDuration = (end - start) * factor;\r\n    \r\n    handleTimeRangeChange([\r\n      center - newDuration / 2,\r\n      center + newDuration / 2\r\n    ], 'zoom');\r\n  }, [synchronizedState.timeRange, handleTimeRangeChange]);\r\n\r\n  const zoomOut = useCallback((factor = 2) => {\r\n    const [start, end] = synchronizedState.timeRange;\r\n    const center = (start + end) / 2;\r\n    const newDuration = (end - start) * factor;\r\n    \r\n    handleTimeRangeChange([\r\n      Math.max(0, center - newDuration / 2),\r\n      Math.min(20, center + newDuration / 2)\r\n    ], 'zoom');\r\n  }, [synchronizedState.timeRange, handleTimeRangeChange]);\r\n\r\n  const panLeft = useCallback((amount = 2) => {\r\n    const [start, end] = synchronizedState.timeRange;\r\n    const duration = end - start;\r\n    \r\n    handleTimeRangeChange([\r\n      Math.max(0, start - amount),\r\n      Math.max(duration, end - amount)\r\n    ], 'pan');\r\n  }, [synchronizedState.timeRange, handleTimeRangeChange]);\r\n\r\n  const panRight = useCallback((amount = 2) => {\r\n    const [start, end] = synchronizedState.timeRange;\r\n    const duration = end - start;\r\n    \r\n    handleTimeRangeChange([\r\n      Math.min(20 - duration, start + amount),\r\n      Math.min(20, end + amount)\r\n    ], 'pan');\r\n  }, [synchronizedState.timeRange, handleTimeRangeChange]);\r\n\r\n  // 9. 리셋 함수\r\n  const resetView = useCallback(() => {\r\n    setSynchronizedState(prev => ({\r\n      ...prev,\r\n      timeRange: [0, 20],\r\n      hoveredTime: null,\r\n      hoveredEvent: null,\r\n      selectedEvent: null,\r\n      selectedTimeRange: null,\r\n      zoomLevel: 1,\r\n      panOffset: 0\r\n    }));\r\n  }, []);\r\n\r\n  // 10. 이벤트 필터링 (현재 시간 범위 기준)\r\n  const getVisibleEvents = useCallback(() => {\r\n    const [start, end] = synchronizedState.timeRange;\r\n    return events.filter(event => event.t >= start && event.t <= end);\r\n  }, [events, synchronizedState.timeRange]);\r\n\r\n  // Clean up\r\n  useEffect(() => {\r\n    return () => {\r\n      Object.values(debounceRef.current).forEach(timeout => {\r\n        if (timeout) clearTimeout(timeout);\r\n      });\r\n    };\r\n  }, []);\r\n\r\n  return {\r\n    // 상태\r\n    synchronizedState,\r\n    \r\n    // 이벤트 핸들러\r\n    onTimeHover: handleTimeHover,\r\n    onEventHover: handleEventHover,\r\n    onTimeRangeChange: handleTimeRangeChange,\r\n    onEventSelect: handleEventSelect,\r\n    updateChartState,\r\n    \r\n    // 줌/팬 컨트롤\r\n    zoomIn,\r\n    zoomOut,\r\n    panLeft,\r\n    panRight,\r\n    resetView,\r\n    \r\n    // 유틸리티\r\n    getVisibleEvents,\r\n    getPerformanceStats,\r\n    \r\n    // 개별 상태 접근자 (편의성)\r\n    timeRange: synchronizedState.timeRange,\r\n    hoveredTime: synchronizedState.hoveredTime,\r\n    hoveredEvent: synchronizedState.hoveredEvent,\r\n    selectedEvent: synchronizedState.selectedEvent,\r\n    zoomLevel: synchronizedState.zoomLevel\r\n  };\r\n};\r\n\r\nexport default useChartSynchronization;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}